<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>非淡泊无以明志，非宁静无以致远。 on 非淡泊无以明志，非宁静无以致远。</title>
    <link>/</link>
    <description>Recent content in 非淡泊无以明志，非宁静无以致远。 on 非淡泊无以明志，非宁静无以致远。</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Sheng Luan</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在R中使用windows系统自带的中文字体</title>
      <link>/post/using-other-system-chinese-fonts-in-r/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/using-other-system-chinese-fonts-in-r/</guid>
      <description>&lt;p&gt;R作图时，如何在图片中使用windows系统自带的其他中文字体？以前尝试过好几次，都没有成功。&lt;/p&gt;
&lt;p&gt;首先安装二个包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/sysfonts/index.html&#34;&gt;sysfonts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/web/packages/showtext/index.html&#34;&gt;showtext&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R中自带的默认字体家族，可以通过sysfonts::font.families()函数查看：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(sysfonts)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: sysfonts&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(showtext)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: showtext&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: showtextdb&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_families()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;sans&amp;quot;         &amp;quot;serif&amp;quot;        &amp;quot;mono&amp;quot;         &amp;quot;wqy-microhei&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R中自带的三种标准字体家族为：&lt;a href=&#34;https://baike.baidu.com/item/衬线字体/6820704?fr=aladdin&#34;&gt;serif&lt;/a&gt;（衬线）、&lt;a href=&#34;https://baike.baidu.com/item/无衬线体/2374029&#34;&gt;sans&lt;/a&gt;（无衬线）和&lt;a href=&#34;https://baike.baidu.com/item/等宽字体/8434037?fr=aladdin&#34;&gt;mono&lt;/a&gt;（等宽）三类。&lt;/p&gt;
&lt;p&gt;如果想使用Windows系统中自带的中文字体，首先查看系统中字体存储路径：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_paths()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;C:\\Windows\\Fonts&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进一步查看有哪些可以利用的字体文件：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_files()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   [1] &amp;quot;AGENCYB.TTF&amp;quot;             &amp;quot;AGENCYR.TTF&amp;quot;            
##   [3] &amp;quot;ALGER.TTF&amp;quot;               &amp;quot;ANTQUAB.TTF&amp;quot;            
##   [5] &amp;quot;ANTQUABI.TTF&amp;quot;            &amp;quot;ANTQUAI.TTF&amp;quot;            
##   [7] &amp;quot;arial.ttf&amp;quot;               &amp;quot;arialbd.ttf&amp;quot;            
##   [9] &amp;quot;arialbi.ttf&amp;quot;             &amp;quot;ariali.ttf&amp;quot;             
##  [11] &amp;quot;ARIALN.TTF&amp;quot;              &amp;quot;ARIALNB.TTF&amp;quot;            
##  [13] &amp;quot;ARIALNBI.TTF&amp;quot;            &amp;quot;ARIALNI.TTF&amp;quot;            
##  [15] &amp;quot;ariblk.ttf&amp;quot;              &amp;quot;ARLRDBD.TTF&amp;quot;            
##  [17] &amp;quot;bahnschrift.ttf&amp;quot;         &amp;quot;BASKVILL.TTF&amp;quot;           
##  [19] &amp;quot;BAUHS93.TTF&amp;quot;             &amp;quot;BELL.TTF&amp;quot;               
##  [21] &amp;quot;BELLB.TTF&amp;quot;               &amp;quot;BELLI.TTF&amp;quot;              
##  [23] &amp;quot;BERNHC.TTF&amp;quot;              &amp;quot;BKANT.TTF&amp;quot;              
##  [25] &amp;quot;BOD_B.TTF&amp;quot;               &amp;quot;BOD_BI.TTF&amp;quot;             
##  [27] &amp;quot;BOD_BLAI.TTF&amp;quot;            &amp;quot;BOD_BLAR.TTF&amp;quot;           
##  [29] &amp;quot;BOD_CB.TTF&amp;quot;              &amp;quot;BOD_CBI.TTF&amp;quot;            
##  [31] &amp;quot;BOD_CI.TTF&amp;quot;              &amp;quot;BOD_CR.TTF&amp;quot;             
##  [33] &amp;quot;BOD_I.TTF&amp;quot;               &amp;quot;BOD_PSTC.TTF&amp;quot;           
##  [35] &amp;quot;BOD_R.TTF&amp;quot;               &amp;quot;BOOKOS.TTF&amp;quot;             
##  [37] &amp;quot;BOOKOSB.TTF&amp;quot;             &amp;quot;BOOKOSBI.TTF&amp;quot;           
##  [39] &amp;quot;BOOKOSI.TTF&amp;quot;             &amp;quot;BRADHITC.TTF&amp;quot;           
##  [41] &amp;quot;BRITANIC.TTF&amp;quot;            &amp;quot;BRLNSB.TTF&amp;quot;             
##  [43] &amp;quot;BRLNSDB.TTF&amp;quot;             &amp;quot;BRLNSR.TTF&amp;quot;             
##  [45] &amp;quot;BROADW.TTF&amp;quot;              &amp;quot;BRUSHSCI.TTF&amp;quot;           
##  [47] &amp;quot;BSSYM7.TTF&amp;quot;              &amp;quot;calibri.ttf&amp;quot;            
##  [49] &amp;quot;calibrib.ttf&amp;quot;            &amp;quot;calibrii.ttf&amp;quot;           
##  [51] &amp;quot;calibril.ttf&amp;quot;            &amp;quot;calibrili.ttf&amp;quot;          
##  [53] &amp;quot;calibriz.ttf&amp;quot;            &amp;quot;CALIFB.TTF&amp;quot;             
##  [55] &amp;quot;CALIFI.TTF&amp;quot;              &amp;quot;CALIFR.TTF&amp;quot;             
##  [57] &amp;quot;CALIST.TTF&amp;quot;              &amp;quot;CALISTB.TTF&amp;quot;            
##  [59] &amp;quot;CALISTBI.TTF&amp;quot;            &amp;quot;CALISTI.TTF&amp;quot;            
##  [61] &amp;quot;cambria.ttc&amp;quot;             &amp;quot;cambriab.ttf&amp;quot;           
##  [63] &amp;quot;cambriai.ttf&amp;quot;            &amp;quot;cambriaz.ttf&amp;quot;           
##  [65] &amp;quot;Candara.ttf&amp;quot;             &amp;quot;Candarab.ttf&amp;quot;           
##  [67] &amp;quot;Candarai.ttf&amp;quot;            &amp;quot;Candaraz.ttf&amp;quot;           
##  [69] &amp;quot;CASTELAR.TTF&amp;quot;            &amp;quot;CENSCBK.TTF&amp;quot;            
##  [71] &amp;quot;CENTAUR.TTF&amp;quot;             &amp;quot;CENTURY.TTF&amp;quot;            
##  [73] &amp;quot;CHILLER.TTF&amp;quot;             &amp;quot;COLONNA.TTF&amp;quot;            
##  [75] &amp;quot;comic.ttf&amp;quot;               &amp;quot;comicbd.ttf&amp;quot;            
##  [77] &amp;quot;comici.ttf&amp;quot;              &amp;quot;comicz.ttf&amp;quot;             
##  [79] &amp;quot;consola.ttf&amp;quot;             &amp;quot;consolab.ttf&amp;quot;           
##  [81] &amp;quot;consolai.ttf&amp;quot;            &amp;quot;consolaz.ttf&amp;quot;           
##  [83] &amp;quot;constan.ttf&amp;quot;             &amp;quot;constanb.ttf&amp;quot;           
##  [85] &amp;quot;constani.ttf&amp;quot;            &amp;quot;constanz.ttf&amp;quot;           
##  [87] &amp;quot;COOPBL.TTF&amp;quot;              &amp;quot;COPRGTB.TTF&amp;quot;            
##  [89] &amp;quot;COPRGTL.TTF&amp;quot;             &amp;quot;corbel.ttf&amp;quot;             
##  [91] &amp;quot;corbelb.ttf&amp;quot;             &amp;quot;corbeli.ttf&amp;quot;            
##  [93] &amp;quot;corbelz.ttf&amp;quot;             &amp;quot;cour.ttf&amp;quot;               
##  [95] &amp;quot;courbd.ttf&amp;quot;              &amp;quot;courbi.ttf&amp;quot;             
##  [97] &amp;quot;couri.ttf&amp;quot;               &amp;quot;CURLZ___.TTF&amp;quot;           
##  [99] &amp;quot;Deng.ttf&amp;quot;                &amp;quot;Dengb.ttf&amp;quot;              
## [101] &amp;quot;Dengl.ttf&amp;quot;               &amp;quot;ebrima.ttf&amp;quot;             
## [103] &amp;quot;ebrimabd.ttf&amp;quot;            &amp;quot;ELEPHNT.TTF&amp;quot;            
## [105] &amp;quot;ELEPHNTI.TTF&amp;quot;            &amp;quot;ENGR.TTF&amp;quot;               
## [107] &amp;quot;ERASBD.TTF&amp;quot;              &amp;quot;ERASDEMI.TTF&amp;quot;           
## [109] &amp;quot;ERASLGHT.TTF&amp;quot;            &amp;quot;ERASMD.TTF&amp;quot;             
## [111] &amp;quot;euclid.ttf&amp;quot;              &amp;quot;euclidb.ttf&amp;quot;            
## [113] &amp;quot;euclidbi.ttf&amp;quot;            &amp;quot;euclidi.ttf&amp;quot;            
## [115] &amp;quot;eucsym.ttf&amp;quot;              &amp;quot;eucsymb.ttf&amp;quot;            
## [117] &amp;quot;eucsymbi.ttf&amp;quot;            &amp;quot;eucsymi.ttf&amp;quot;            
## [119] &amp;quot;euextra.ttf&amp;quot;             &amp;quot;euextrab.ttf&amp;quot;           
## [121] &amp;quot;eufrak.ttf&amp;quot;              &amp;quot;eufrakb.ttf&amp;quot;            
## [123] &amp;quot;eumat1.ttf&amp;quot;              &amp;quot;eumat1b.ttf&amp;quot;            
## [125] &amp;quot;eumat2.ttf&amp;quot;              &amp;quot;eumat2b.ttf&amp;quot;            
## [127] &amp;quot;FELIXTI.TTF&amp;quot;             &amp;quot;fences.ttf&amp;quot;             
## [129] &amp;quot;FORTE.TTF&amp;quot;               &amp;quot;FRABK.TTF&amp;quot;              
## [131] &amp;quot;FRABKIT.TTF&amp;quot;             &amp;quot;FRADM.TTF&amp;quot;              
## [133] &amp;quot;FRADMCN.TTF&amp;quot;             &amp;quot;FRADMIT.TTF&amp;quot;            
## [135] &amp;quot;FRAHV.TTF&amp;quot;               &amp;quot;FRAHVIT.TTF&amp;quot;            
## [137] &amp;quot;framd.ttf&amp;quot;               &amp;quot;FRAMDCN.TTF&amp;quot;            
## [139] &amp;quot;framdit.ttf&amp;quot;             &amp;quot;FREESCPT.TTF&amp;quot;           
## [141] &amp;quot;FRSCRIPT.TTF&amp;quot;            &amp;quot;FTLTLT.TTF&amp;quot;             
## [143] &amp;quot;FZSTK.TTF&amp;quot;               &amp;quot;FZYTK.TTF&amp;quot;              
## [145] &amp;quot;Gabriola.ttf&amp;quot;            &amp;quot;gadugi.ttf&amp;quot;             
## [147] &amp;quot;gadugib.ttf&amp;quot;             &amp;quot;GARA.TTF&amp;quot;               
## [149] &amp;quot;GARABD.TTF&amp;quot;              &amp;quot;GARAIT.TTF&amp;quot;             
## [151] &amp;quot;georgia.ttf&amp;quot;             &amp;quot;georgiab.ttf&amp;quot;           
## [153] &amp;quot;georgiai.ttf&amp;quot;            &amp;quot;georgiaz.ttf&amp;quot;           
## [155] &amp;quot;GIGI.TTF&amp;quot;                &amp;quot;GIL_____.TTF&amp;quot;           
## [157] &amp;quot;GILB____.TTF&amp;quot;            &amp;quot;GILBI___.TTF&amp;quot;           
## [159] &amp;quot;GILC____.TTF&amp;quot;            &amp;quot;GILI____.TTF&amp;quot;           
## [161] &amp;quot;GILLUBCD.TTF&amp;quot;            &amp;quot;GILSANUB.TTF&amp;quot;           
## [163] &amp;quot;GLECB.TTF&amp;quot;               &amp;quot;GLSNECB.TTF&amp;quot;            
## [165] &amp;quot;GOTHIC.TTF&amp;quot;              &amp;quot;GOTHICB.TTF&amp;quot;            
## [167] &amp;quot;GOTHICBI.TTF&amp;quot;            &amp;quot;GOTHICI.TTF&amp;quot;            
## [169] &amp;quot;GOUDOS.TTF&amp;quot;              &amp;quot;GOUDOSB.TTF&amp;quot;            
## [171] &amp;quot;GOUDOSI.TTF&amp;quot;             &amp;quot;GOUDYSTO.TTF&amp;quot;           
## [173] &amp;quot;HARLOWSI.TTF&amp;quot;            &amp;quot;HARNGTON.TTF&amp;quot;           
## [175] &amp;quot;HATTEN.TTF&amp;quot;              &amp;quot;himalaya.ttf&amp;quot;           
## [177] &amp;quot;holomdl2.ttf&amp;quot;            &amp;quot;HTOWERT.TTF&amp;quot;            
## [179] &amp;quot;HTOWERTI.TTF&amp;quot;            &amp;quot;impact.ttf&amp;quot;             
## [181] &amp;quot;IMPRISHA.TTF&amp;quot;            &amp;quot;INFROMAN.TTF&amp;quot;           
## [183] &amp;quot;iqiyi_logov4.ttf&amp;quot;        &amp;quot;ITCBLKAD.TTF&amp;quot;           
## [185] &amp;quot;ITCEDSCR.TTF&amp;quot;            &amp;quot;ITCKRIST.TTF&amp;quot;           
## [187] &amp;quot;javatext.ttf&amp;quot;            &amp;quot;JOKERMAN.TTF&amp;quot;           
## [189] &amp;quot;JUICE___.TTF&amp;quot;            &amp;quot;KUNSTLER.TTF&amp;quot;           
## [191] &amp;quot;l_10646.ttf&amp;quot;             &amp;quot;LATINWD.TTF&amp;quot;            
## [193] &amp;quot;LBRITE.TTF&amp;quot;              &amp;quot;LBRITED.TTF&amp;quot;            
## [195] &amp;quot;LBRITEDI.TTF&amp;quot;            &amp;quot;LBRITEI.TTF&amp;quot;            
## [197] &amp;quot;LCALLIG.TTF&amp;quot;             &amp;quot;LeelaUIb.ttf&amp;quot;           
## [199] &amp;quot;LeelawUI.ttf&amp;quot;            &amp;quot;LeelUIsl.ttf&amp;quot;           
## [201] &amp;quot;LFAX.TTF&amp;quot;                &amp;quot;LFAXD.TTF&amp;quot;              
## [203] &amp;quot;LFAXDI.TTF&amp;quot;              &amp;quot;LFAXI.TTF&amp;quot;              
## [205] &amp;quot;LHANDW.TTF&amp;quot;              &amp;quot;LSANS.TTF&amp;quot;              
## [207] &amp;quot;LSANSD.TTF&amp;quot;              &amp;quot;LSANSDI.TTF&amp;quot;            
## [209] &amp;quot;LSANSI.TTF&amp;quot;              &amp;quot;LTYPE.TTF&amp;quot;              
## [211] &amp;quot;LTYPEB.TTF&amp;quot;              &amp;quot;LTYPEBO.TTF&amp;quot;            
## [213] &amp;quot;LTYPEO.TTF&amp;quot;              &amp;quot;lucon.ttf&amp;quot;              
## [215] &amp;quot;MAGNETOB.TTF&amp;quot;            &amp;quot;MAIAN.TTF&amp;quot;              
## [217] &amp;quot;malgun.ttf&amp;quot;              &amp;quot;malgunbd.ttf&amp;quot;           
## [219] &amp;quot;malgunsl.ttf&amp;quot;            &amp;quot;marlett.ttf&amp;quot;            
## [221] &amp;quot;MATURASC.TTF&amp;quot;            &amp;quot;micross.ttf&amp;quot;            
## [223] &amp;quot;mingliub.ttc&amp;quot;            &amp;quot;MISTRAL.TTF&amp;quot;            
## [225] &amp;quot;mmrtext.ttf&amp;quot;             &amp;quot;mmrtextb.ttf&amp;quot;           
## [227] &amp;quot;MOD20.TTF&amp;quot;               &amp;quot;monbaiti.ttf&amp;quot;           
## [229] &amp;quot;msgothic.ttc&amp;quot;            &amp;quot;msjh.ttc&amp;quot;               
## [231] &amp;quot;msjhbd.ttc&amp;quot;              &amp;quot;msjhl.ttc&amp;quot;              
## [233] &amp;quot;msyh.ttc&amp;quot;                &amp;quot;msyhbd.ttc&amp;quot;             
## [235] &amp;quot;msyhl.ttc&amp;quot;               &amp;quot;msyi.ttf&amp;quot;               
## [237] &amp;quot;Mt Extra Tiger.ttf&amp;quot;      &amp;quot;MTCORSVA.TTF&amp;quot;           
## [239] &amp;quot;mtextra.ttf&amp;quot;             &amp;quot;mvboli.ttf&amp;quot;             
## [241] &amp;quot;NIAGENG.TTF&amp;quot;             &amp;quot;NIAGSOL.TTF&amp;quot;            
## [243] &amp;quot;Nirmala.ttf&amp;quot;             &amp;quot;NirmalaB.ttf&amp;quot;           
## [245] &amp;quot;NirmalaS.ttf&amp;quot;            &amp;quot;ntailu.ttf&amp;quot;             
## [247] &amp;quot;ntailub.ttf&amp;quot;             &amp;quot;OCRAEXT.TTF&amp;quot;            
## [249] &amp;quot;OLDENGL.TTF&amp;quot;             &amp;quot;ONYX.TTF&amp;quot;               
## [251] &amp;quot;OUTLOOK.TTF&amp;quot;             &amp;quot;pala.ttf&amp;quot;               
## [253] &amp;quot;palab.ttf&amp;quot;               &amp;quot;palabi.ttf&amp;quot;             
## [255] &amp;quot;palai.ttf&amp;quot;               &amp;quot;PALSCRI.TTF&amp;quot;            
## [257] &amp;quot;PAPYRUS.TTF&amp;quot;             &amp;quot;PARCHM.TTF&amp;quot;             
## [259] &amp;quot;PER_____.TTF&amp;quot;            &amp;quot;PERB____.TTF&amp;quot;           
## [261] &amp;quot;PERBI___.TTF&amp;quot;            &amp;quot;PERI____.TTF&amp;quot;           
## [263] &amp;quot;PERTIBD.TTF&amp;quot;             &amp;quot;PERTILI.TTF&amp;quot;            
## [265] &amp;quot;phagspa.ttf&amp;quot;             &amp;quot;phagspab.ttf&amp;quot;           
## [267] &amp;quot;PLAYBILL.TTF&amp;quot;            &amp;quot;POORICH.TTF&amp;quot;            
## [269] &amp;quot;PRISTINA.TTF&amp;quot;            &amp;quot;RAGE.TTF&amp;quot;               
## [271] &amp;quot;RAVIE.TTF&amp;quot;               &amp;quot;REFSAN.TTF&amp;quot;             
## [273] &amp;quot;REFSPCL.TTF&amp;quot;             &amp;quot;ROCC____.TTF&amp;quot;           
## [275] &amp;quot;ROCCB___.TTF&amp;quot;            &amp;quot;ROCK.TTF&amp;quot;               
## [277] &amp;quot;ROCKB.TTF&amp;quot;               &amp;quot;ROCKBI.TTF&amp;quot;             
## [279] &amp;quot;ROCKEB.TTF&amp;quot;              &amp;quot;ROCKI.TTF&amp;quot;              
## [281] &amp;quot;SCHLBKB.TTF&amp;quot;             &amp;quot;SCHLBKBI.TTF&amp;quot;           
## [283] &amp;quot;SCHLBKI.TTF&amp;quot;             &amp;quot;SCRIPTBL.TTF&amp;quot;           
## [285] &amp;quot;segmdl2.ttf&amp;quot;             &amp;quot;segoepr.ttf&amp;quot;            
## [287] &amp;quot;segoeprb.ttf&amp;quot;            &amp;quot;segoesc.ttf&amp;quot;            
## [289] &amp;quot;segoescb.ttf&amp;quot;            &amp;quot;segoeui.ttf&amp;quot;            
## [291] &amp;quot;segoeuib.ttf&amp;quot;            &amp;quot;segoeuii.ttf&amp;quot;           
## [293] &amp;quot;segoeuil.ttf&amp;quot;            &amp;quot;segoeuisl.ttf&amp;quot;          
## [295] &amp;quot;segoeuiz.ttf&amp;quot;            &amp;quot;seguibl.ttf&amp;quot;            
## [297] &amp;quot;seguibli.ttf&amp;quot;            &amp;quot;seguiemj.ttf&amp;quot;           
## [299] &amp;quot;seguihis.ttf&amp;quot;            &amp;quot;seguili.ttf&amp;quot;            
## [301] &amp;quot;seguisb.ttf&amp;quot;             &amp;quot;seguisbi.ttf&amp;quot;           
## [303] &amp;quot;seguisli.ttf&amp;quot;            &amp;quot;seguisym.ttf&amp;quot;           
## [305] &amp;quot;SHOWG.TTF&amp;quot;               &amp;quot;simfang.ttf&amp;quot;            
## [307] &amp;quot;simhei.ttf&amp;quot;              &amp;quot;simkai.ttf&amp;quot;             
## [309] &amp;quot;SIMLI.TTF&amp;quot;               &amp;quot;simsun.ttc&amp;quot;             
## [311] &amp;quot;simsunb.ttf&amp;quot;             &amp;quot;SIMYOU.TTF&amp;quot;             
## [313] &amp;quot;Sitka.ttc&amp;quot;               &amp;quot;SitkaB.ttc&amp;quot;             
## [315] &amp;quot;SitkaI.ttc&amp;quot;              &amp;quot;SitkaZ.ttc&amp;quot;             
## [317] &amp;quot;SNAP____.TTF&amp;quot;            &amp;quot;STCAIYUN.TTF&amp;quot;           
## [319] &amp;quot;STENCIL.TTF&amp;quot;             &amp;quot;STFANGSO.TTF&amp;quot;           
## [321] &amp;quot;STHUPO.TTF&amp;quot;              &amp;quot;STKAITI.TTF&amp;quot;            
## [323] &amp;quot;STLITI.TTF&amp;quot;              &amp;quot;STSONG.TTF&amp;quot;             
## [325] &amp;quot;STXIHEI.TTF&amp;quot;             &amp;quot;STXINGKA.TTF&amp;quot;           
## [327] &amp;quot;STXINWEI.TTF&amp;quot;            &amp;quot;STZHONGS.TTF&amp;quot;           
## [329] &amp;quot;sylfaen.ttf&amp;quot;             &amp;quot;Symbol Tiger Expert.ttf&amp;quot;
## [331] &amp;quot;Symbol Tiger.ttf&amp;quot;        &amp;quot;symbol.ttf&amp;quot;             
## [333] &amp;quot;tahoma.ttf&amp;quot;              &amp;quot;tahomabd.ttf&amp;quot;           
## [335] &amp;quot;taile.ttf&amp;quot;               &amp;quot;taileb.ttf&amp;quot;             
## [337] &amp;quot;TCB_____.TTF&amp;quot;            &amp;quot;TCBI____.TTF&amp;quot;           
## [339] &amp;quot;TCCB____.TTF&amp;quot;            &amp;quot;TCCEB.TTF&amp;quot;              
## [341] &amp;quot;TCCM____.TTF&amp;quot;            &amp;quot;TCM_____.TTF&amp;quot;           
## [343] &amp;quot;TCMI____.TTF&amp;quot;            &amp;quot;TEMPSITC.TTF&amp;quot;           
## [345] &amp;quot;Tiger Expert.ttf&amp;quot;        &amp;quot;Tiger.ttf&amp;quot;              
## [347] &amp;quot;times.ttf&amp;quot;               &amp;quot;timesbd.ttf&amp;quot;            
## [349] &amp;quot;timesbi.ttf&amp;quot;             &amp;quot;timesi.ttf&amp;quot;             
## [351] &amp;quot;trebuc.ttf&amp;quot;              &amp;quot;trebucbd.ttf&amp;quot;           
## [353] &amp;quot;trebucbi.ttf&amp;quot;            &amp;quot;trebucit.ttf&amp;quot;           
## [355] &amp;quot;verdana.ttf&amp;quot;             &amp;quot;verdanab.ttf&amp;quot;           
## [357] &amp;quot;verdanai.ttf&amp;quot;            &amp;quot;verdanaz.ttf&amp;quot;           
## [359] &amp;quot;VINERITC.TTF&amp;quot;            &amp;quot;VIVALDII.TTF&amp;quot;           
## [361] &amp;quot;VLADIMIR.TTF&amp;quot;            &amp;quot;webdings.ttf&amp;quot;           
## [363] &amp;quot;wingding.ttf&amp;quot;            &amp;quot;WINGDNG2.TTF&amp;quot;           
## [365] &amp;quot;WINGDNG3.TTF&amp;quot;            &amp;quot;YuGothB.ttc&amp;quot;            
## [367] &amp;quot;YuGothL.ttc&amp;quot;             &amp;quot;YuGothM.ttc&amp;quot;            
## [369] &amp;quot;YuGothR.ttc&amp;quot;             &amp;quot;ZWAdobeF.TTF&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中宋体文件是simsun.ttc，黑体文件是：simhei.ttf，楷体文件是simkai.ttf，微软雅黑是msyh.ttf和msyhbd.ttf。&lt;/p&gt;
&lt;p&gt;尝试在R环境中加入黑体（如果字体是在Windows系统的默认字体库中，regular可以不用指定路径）：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_add(family = &amp;quot;heiti&amp;quot;,regular = &amp;quot;simhei.ttf&amp;quot;)
font_add(family = &amp;quot;kaiti&amp;quot;,regular = &amp;quot;simkai.ttf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时查看R中自带字体，你会发现多了“heiti”和“kaiti”。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font.families()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## &amp;#39;font.families()&amp;#39; is now renamed to &amp;#39;font_families()&amp;#39;
## The old version still works, but consider using the new function in future code&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;sans&amp;quot;         &amp;quot;serif&amp;quot;        &amp;quot;mono&amp;quot;         &amp;quot;wqy-microhei&amp;quot;
## [5] &amp;quot;heiti&amp;quot;        &amp;quot;kaiti&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我们在画图中使用黑体，借用showtext包作者邱逸轩的这篇文章&lt;a href=&#34;https://cosx.org/2014/01/showtext-interesting-fonts-and-graphs&#34;&gt;showtext：字体，好玩的字体和好玩的图形&lt;/a&gt;中的r示例代码：&lt;/p&gt;
&lt;p&gt;需要注意，&lt;strong&gt;rstudio自带的Plots面板中绘出的图形不显示自定义字体&lt;/strong&gt;，这也是以前总是觉得设置自定义字体不成功的原因。在运行下面的代码前，调用windows()函数打开一个新的图形接收窗口，下边代码绘制的图形会显示其中。&lt;/p&gt;
&lt;p&gt;如果你打算在Rmd文档中使用showtext包，请在chunk头参数中设置fig.showtext=TRUE。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;showtext::showtext_auto() #这样代码非常重要
set.seed(123)
plot(1, xlim = c(-3, 3), ylim = c(-3, 3), type = &amp;quot;n&amp;quot;)
text(runif(100, -3, 3), runif(100, -3, 3),
     intToUtf8(round(runif(100, 19968, 40869)), multiple = TRUE),
     col = rgb(runif(100), runif(100), runif(100), 0.5 + runif(100)/2),
     cex = 2, family = &amp;quot;heiti&amp;quot;)   # 指定heiti字体
title(&amp;quot;随机汉字&amp;quot;, family = &amp;quot;kaiti&amp;quot;)   # 指定kaiti字体&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-12-31-using-other-system-chinese-fonts-in-r_files/figure-html/fontexample-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ok!大功告成！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Take me to  your heart</title>
      <link>/post/take-me-to-your-heart/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/take-me-to-your-heart/</guid>
      <description>&lt;p&gt;Hiding from the rain and snow&lt;/p&gt;

&lt;p&gt;Trying to forget but I won&amp;rsquo;t let go&lt;/p&gt;

&lt;p&gt;Looking at a crowded street&lt;/p&gt;

&lt;p&gt;Listening to my own heart beat&lt;/p&gt;

&lt;p&gt;So many people all around the world&lt;/p&gt;

&lt;p&gt;Tell me where do I find someone like you girl&lt;/p&gt;

&lt;p&gt;(Chorus)&lt;/p&gt;

&lt;p&gt;Take me to your heart take me to your soul&lt;/p&gt;

&lt;p&gt;Give me your hand before I&amp;rsquo;m old&lt;/p&gt;

&lt;p&gt;Show me what love is - haven&amp;rsquo;t got a clue&lt;/p&gt;

&lt;p&gt;Show me that wonders can be true&lt;/p&gt;

&lt;p&gt;They say nothing lasts forever&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re only here today&lt;/p&gt;

&lt;p&gt;Love is now or never&lt;/p&gt;

&lt;p&gt;Bring me far away&lt;/p&gt;

&lt;p&gt;Take me to your heart take me to your soul&lt;/p&gt;

&lt;p&gt;Give me your hand and hold me&lt;/p&gt;

&lt;p&gt;Show me what love is - be my guiding star&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy take me to your heart&lt;/p&gt;

&lt;p&gt;Standing on a mountain high&lt;/p&gt;

&lt;p&gt;Looking at the moon through a clear blue sky&lt;/p&gt;

&lt;p&gt;I should go and see some friends&lt;/p&gt;

&lt;p&gt;But they don&amp;rsquo;t really comprehend&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t need too much talking without saying anything&lt;/p&gt;

&lt;p&gt;All I need is someone who makes me wanna sing&lt;/p&gt;

&lt;p&gt;Take me to your heart take me to your soul&lt;/p&gt;

&lt;p&gt;Give me your hand before I&amp;rsquo;m old&lt;/p&gt;

&lt;p&gt;Show me what love is - haven&amp;rsquo;t got a clue&lt;/p&gt;

&lt;p&gt;Show me that wonders can be true&lt;/p&gt;

&lt;p&gt;They say nothing lasts forever&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re only here today&lt;/p&gt;

&lt;p&gt;Love is now or never&lt;/p&gt;

&lt;p&gt;Bring me far away&lt;/p&gt;

&lt;p&gt;Take me to your heart take me to your soul&lt;/p&gt;

&lt;p&gt;Give me your hand and hold me&lt;/p&gt;

&lt;p&gt;Show me what love is - be my guiding star&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy take me to your heart&lt;/p&gt;

&lt;p&gt;Take me to your heart take me to your soul&lt;/p&gt;

&lt;p&gt;Give me your hand and hold me&lt;/p&gt;

&lt;p&gt;Show me what love is - be my guiding star&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy take me to your heart&lt;/p&gt;

&lt;p&gt;(Chorus)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自由度和方差分析</title>
      <link>/post/df-and-anova/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/df-and-anova/</guid>
      <description>&lt;p&gt;比较同一处理不同水平的差异，譬如不同养殖密度、不同饲料对生长速度的影响，经常会用到方差分析的方法。而在方差分析中，自由度是一个非常重要的概念。这篇博客记录对这两个概念的理解。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1. 自由度&lt;/h2&gt;
&lt;p&gt;自由度（Degrees of freedom）是统计学上最经常见到的一个概念。关于它的概念，第一次接触，理解起来有些困难。维基百科的&lt;a href=&#34;https://en.wikipedia.org/wiki/Degrees_of_freedom_(statistics)&#34;&gt;解释&lt;/a&gt;是这样的: “In statistics, the number of degrees of freedom is the number of values in the final calculation of a statistic that are free to vary”。试着翻译：“在统计学中，自由度的个数被定义为，在一个统计参数的计算过程中，可以&lt;strong&gt;自由变化的数值的个数&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;维基百科中，以方差为例，试着给出自由度的计算方法。&lt;/p&gt;
&lt;p&gt;In general, the degrees of freedom of an estimate of a parameter are equal to the number of independent scores that go into the estimate minus the number of parameters used as intermediate steps in the estimation of the parameter itself (e.g. the sample variance has N − 1 degrees of freedom, since it is computed from N random scores minus the only 1 parameter estimated as intermediate step, which is the sample mean).&lt;/p&gt;
&lt;p&gt;翻译：一般来讲，一个参数估计值的自由度等于， 在估计过程中使用的独立样本（score）个数，减掉中间步骤中用到的参数个数。以方差为例，它的自由度为N-1，是因为计算方需要n个独立样本值，而在中间计算过程中用到了样本均值这个参数，所以自由度为n-1。&lt;/p&gt;
&lt;p&gt;方差的计算公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[Var(Y) =\frac{\sum_{i=1}^{n} (y_{i}-\bar{y})^{2}}{n-1}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结合百度百科关于&lt;a href=&#34;https://baike.baidu.com/item/%E8%87%AA%E7%94%B1%E5%BA%A6/5936984?fr=aladdin&#34;&gt;方差自由度&lt;/a&gt;的解释，感觉可以这样理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在估计总体的平均数时，由于样本中的 n 个数都是相互独立的，从其中抽出任何一个数都不影响其他数据，所以其自由度为n。&lt;/li&gt;
&lt;li&gt;在估计总体的方差时，使用的是离差平方和。&lt;strong&gt;由上面的公式可知，计算方差需要首先获得n个数的平均值。一旦平均数确定了，那么在计算方差时，只要n-1个数的离差平方和确定了，方差也就确定了；因为在均值确定后，如果知道了其中n-1个数的值，第n个数的值也就确定了&lt;/strong&gt;。这里，均值就相当于一个限制条件，由于加了这个限制条件，估计总体方差的自由度为n-1。&lt;/li&gt;
&lt;li&gt;例如，我们有5尾虾的体重数据（n=5），想估计其方差。计算得到5尾虾的平均值为&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;=20g，那么方差就会即受到&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;=20g的条件限制。因为随机选择4尾虾18g、22g、23g、17g计算得到离差平方和后，第5尾虾的体重，根据均值可以算出来，它的离差平方和也就确定了。因而自由度df=n-1=5-1=4，这表示&lt;strong&gt;第5尾虾的离差是依赖平均数&lt;/strong&gt;，受到平均数限制的。推而广之，任何统计量的自由度df=n-k（k为限制条件的个数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;知乎上关于&lt;a href=&#34;https://www.zhihu.com/question/20983193&#34;&gt;自由度&lt;/a&gt;的解释非常专业，建议前往理解和学习，有一些非常难以理解。答主&lt;a href=&#34;https://www.zhihu.com/people/SigmaWang&#34;&gt;Wang Sigma&lt;/a&gt;的一句话，是我能够理解的“本质上，&lt;strong&gt;自由度是做一个估计（推测）时，所拥有的独立信息（证据）的数量&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;方差分析，需要用到自由度，下边结合方差分析，来研究自由度的变化。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;analysis-of-varianceanova&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2. 方差分析（analysis of variance，ANOVA）&lt;/h2&gt;
&lt;p&gt;在育种工作中，我们经常会通过各种试验来分析不同的因素对试验结果的影响。譬如设计实验，分析不同养殖密度、不同饲料种类对生长速度的影响，找出最好的那个水平。&lt;/p&gt;
&lt;p&gt;ANOVA分析，可以用来实现上述目的。主要是用来检测分类变量的效应，也就是我们在线性混合效应模型中常说的固定效应。譬如不同性别、不同群体的差异。&lt;/p&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.1 生成数据&lt;/h3&gt;
&lt;p&gt;我们同样以对虾为例，生成投喂四种饲料后的体重数据。饲料种类称为一个处理，每种饲料是一个水平。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(data.table)
require(ggplot2)
feed.1 &amp;lt;- rnorm(n=100,mean = 25,sd = 6)
feed.2 &amp;lt;- rnorm(n=100,mean = 20,sd = 6)
feed.3 &amp;lt;- rnorm(n=100,mean = 15,sd = 6)
feed.4 &amp;lt;- rnorm(n=100,mean = 10,sd = 6)

feed &amp;lt;- data.table(F1=feed.1,F2=feed.2,F3=feed.3,F4=feed.4)
feed.new &amp;lt;- melt(feed,measure.vars = 1:4)
setnames(feed.new,colnames(feed.new),c(&amp;quot;Feed&amp;quot;,&amp;quot;Weight&amp;quot;))

ggplot(data=feed.new,aes(x=Feed,y=Weight,color=Feed)) + 
  geom_boxplot(outlier.size = 0)+
  geom_jitter(alpha=0.3)+
  labs(x=&amp;quot;饲料种类&amp;quot;,y=&amp;quot;体重&amp;quot;)+
  theme_gray(base_size = 20)+
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:generate&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-12-08-df-and-anova_files/figure-html/generate-1.png&#34; alt=&#34;投喂不同饲料种类后对虾体重分布箱形图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: 投喂不同饲料种类后对虾体重分布箱形图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;通过上图，从体重均值上可以看出，四种饲料间存在差别。但是，我们需要回答以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种差异有没有偶然因素？从上图中可以看出，每种饲料试验虾的体重都存在较大的变异范围。&lt;/li&gt;
&lt;li&gt;样本量和实验设计是否满足要求？&lt;/li&gt;
&lt;li&gt;结果可靠吗？如何对结果的可靠性进行检验？&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.2 方差分析的基本概念&lt;/h3&gt;
&lt;p&gt;这就需要统计学手段帮我们回答。&lt;/p&gt;
&lt;p&gt;首先我们设定一个无效假设：四种饲料投喂对虾后，体重均值相等，没有差异。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[H_{0}: \mu_{1} = \mu_{2} = \mu_{3} = \mu_{4}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后建立数学模型，检验&lt;span class=&#34;math inline&#34;&gt;\(\mu_{i}\)&lt;/span&gt;间的差异程度。如果各水平间差异显著，那么就会得出备择假设：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(H_{1}: \mu_{1}, \mu_{2}, \mu_{3}, \mu_{4}\)&lt;/span&gt;不全相等。&lt;/p&gt;
&lt;p&gt;我们以单因素方差分析(one-way ANOVA）为例，建立分析不同饲料投喂后体重差异的数学模型：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left\{\begin{matrix}
y_{ij} = \mu + \alpha_{i} + \varepsilon_{ij} \\ 
\varepsilon_{ij} \sim N(0,\sigma^{2}) \\ 
\sum_{i=1}^{r}n\alpha_{i} = 0
\end{matrix}\right.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上边公式中i=1, 2,…,4，表示饲料种类；&lt;span class=&#34;math inline&#34;&gt;\(y_{ij}\)&lt;/span&gt;表示投喂第i种饲料后第j尾对虾的体重；&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;为总体均值；&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\alpha_{i}\)&lt;/span&gt;表示第i种饲料的固定效应，&lt;span class=&#34;math inline&#34;&gt;\(\alpha_{i} = \mu_{i} - \mu\)&lt;/span&gt;，其中&lt;span class=&#34;math inline&#34;&gt;\(\mu_{i}\)&lt;/span&gt;是第i种饲料的均值；&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt;表示残差，它符合正态分布：均值为0，方差为&lt;span class=&#34;math inline&#34;&gt;\(\sigma^{2}\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;要想满足&lt;span class=&#34;math inline&#34;&gt;\(\sum_{i=1}^{r}n\alpha_{i} = 0\)&lt;/span&gt;这个条件，每个水平下的样本数都应该是一致的。其中r=4，表示四种饲料；n表示每种饲料水平参与测试的样本数。&lt;/p&gt;
&lt;p&gt;上述公式表明：如果要对数据进行方差分析，要满足3个基本条件（从线性模型角度看，这三个基本条件非常容易理解）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可加性。主要是指处理效应&lt;span class=&#34;math inline&#34;&gt;\(\alpha_{i}\)&lt;/span&gt;与残差&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt;效应是独立的，因此可以加在一起；&lt;/li&gt;
&lt;li&gt;独立正态性。指的是实验误差&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{ij}\)&lt;/span&gt;应当符合正态分布，而且相互间独立；&lt;/li&gt;
&lt;li&gt;方差齐性。主要指的是不同处理的方差应该是一致的。也就是说，需要满足假设“&lt;span class=&#34;math inline&#34;&gt;\(\sigma^{2}_{1} = \sigma^{2}_{2} = ... = \sigma^{2}_{r}\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;2.3 总变异的剖分&lt;/h3&gt;
&lt;p&gt;下边我们进入正题。如何比较处理间的差异？ANOVA的思路是把测量数据的总变异分解为由处理各水平引起的变异和误差变异两部分，然后比较这两部分的大小，通过F检验确定由处理产生的变异是否达到显著水平。&lt;/p&gt;
&lt;p&gt;为了检验&lt;span class=&#34;math inline&#34;&gt;\(H_{0}\)&lt;/span&gt;假设，对平方和、自由度进行分解：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_{T} = \sum_{i=1}^{r}\sum_{j=1}^{n_{i}}(y_{ij}-\bar{y_{\cdot\cdot}})^{2}\)&lt;/span&gt;，&lt;span class=&#34;math inline&#34;&gt;\(\bar{y} = \frac{1}{n}\sum_{i=1}^{r}\sum_{j=1}^{n_{i}}y_{ij}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(S_{T}\)&lt;/span&gt;称为总离差平方和，是每个样本数据&lt;span class=&#34;math inline&#34;&gt;\(y_{ij}\)&lt;/span&gt;与总体均值&lt;span class=&#34;math inline&#34;&gt;\(\bar{y_{\cdot\cdot}}\)&lt;/span&gt;差的平方和。实际上描绘了总体数据的离散程度。&lt;/p&gt;
&lt;p&gt;总离差平方和可以进一步分解为处理平方和、误差平方和：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S_{T} = S_{A} + S_{E}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中处理平方和：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
S_{A} = \sum_{i=1}^{r}\sum_{j=1}^{n}(y_{i\cdot}-\bar{y_{\cdot\cdot}})^{2} \\
 =  n\sum_{i=1}^{r}(y_{i\cdot}-\bar{y_{\cdot\cdot}})^{2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;误差平方和：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S_{E} = \sum_{i=1}^{r}\sum_{j=1}^{n}(y_{ij}-\bar{y_{i\cdot}})^{2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;推导过程： &lt;span class=&#34;math display&#34;&gt;\[
S_{T} =  \sum_{i=1}^{r}\sum_{j=1}^{n}(y_{ij}-\bar{y_{\cdot\cdot}})^{2} \\
= \sum_{i=1}^{r}\sum_{j=1}^{n}[(y_{ij}-\bar{y_{i\cdot}})+(\bar{y_{i\cdot}}-\bar{y_{\cdot\cdot}})]^{2} \\
= \sum_{i=1}^{r}\sum_{j=1}^{n}(y_{ij}-\bar{y_{i\cdot}})^2+2\sum_{i=1}^{r}\sum_{j=1}^{n}(y_{ij}-\bar{y_{i\cdot}})(\bar{y_{i\cdot}}-\bar{y_{\cdot\cdot}})+\sum_{i=1}^{r}\sum_{j=1}^{n}(\bar{y_{i\cdot}}-\bar{y_{\cdot\cdot}})^{2} 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于上边公式中，中间部分为0，因此可以直接推导出：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
S_{T} = \sum_{i=1}^{r}\sum_{j=1}^{n}(y_{ij}-\bar{y_{i\cdot}})^2+\sum_{i=1}^{r}\sum_{j=1}^{n}(\bar{y_{i\cdot}}-\bar{y_{\cdot\cdot}})^{2}  \\
 = S_{E} + S_{A}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下边结合第一部分自由度的基础概念，来推导&lt;span class=&#34;math inline&#34;&gt;\(S_{T}\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(S_{A}\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(S_{E}\)&lt;/span&gt;的自由度。&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&#34;math inline&#34;&gt;\(S_{T}\)&lt;/span&gt;，有rn个样本，根据公式只受总体均值的约束，因此自由度为&lt;span class=&#34;math inline&#34;&gt;\(df_{T}=rn-1\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&#34;math inline&#34;&gt;\(S_{A}\)&lt;/span&gt;，有r个水平，根据公式只受总体均值的约束，因此自由度为&lt;span class=&#34;math inline&#34;&gt;\(df_{A}=r-1\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&#34;math inline&#34;&gt;\(S_{E}\)&lt;/span&gt;，查看它的公式，可以推出，对于处理的每个水平，受各自均值的约束，自由度为n-1，因此r个处理的自由度为&lt;span class=&#34;math inline&#34;&gt;\(df_{E} = r(n-1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算自由度的目的是什么？&lt;/strong&gt;有什么用？下边在计算均方时，检验变异的显著性时将会用到。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>线性混合效应模型教程2</title>
      <link>/post/lmm-tutorial-2/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/lmm-tutorial-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://luansheng.netlify.com/post/lmm-tutorial-1/&#34;&gt;上接线性混合效应模型教程1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本部分可能会用到的R包，请提前安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ggplot2 #优秀的作图包&lt;/li&gt;
&lt;li&gt;data.table #优秀的数据转换处理包&lt;/li&gt;
&lt;li&gt;lme4 #提供lmer函数，进行lmm分析&lt;/li&gt;
&lt;li&gt;lmerTest #提供anova函数，对固定效应进行显著性检验&lt;/li&gt;
&lt;li&gt;sjPlot #lmm结果的可视化展示&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.4 包括随机效应的线性混合效应模型&lt;/h3&gt;
&lt;p&gt;请加载一个新的数据集&lt;a href=&#34;https://luansheng.netlify.com/post/shrimpex.csv&#34;&gt;shrimpex.csv&lt;/a&gt;，其中有一个PopID字段，包括Pop1到Pop4共计4个水平，表示shrimp数据由四个群体组成。现在考虑这样一个问题：四个群体间收获体重是否存在差异。&lt;/p&gt;
&lt;p&gt;首先加载数据文件。画出四个群体收获体重的箱形图，加上jitter点。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp &amp;lt;- fread(input = &amp;quot;shrimpex.csv&amp;quot;,sep = &amp;quot;,&amp;quot;,header = TRUE,stringsAsFactors = TRUE)
str(shrimp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;data.table&amp;#39; and &amp;#39;data.frame&amp;#39;:   4282 obs. of  10 variables:
##  $ AnimalID: Factor w/ 4282 levels &amp;quot;13G1000001&amp;quot;,&amp;quot;13G1000002&amp;quot;,..: 3308 3307 2215 1303 3601 2184 2194 2175 1585 2176 ...
##  $ SireID  : Factor w/ 100 levels &amp;quot;12G000K010&amp;quot;,&amp;quot;12G000K065&amp;quot;,..: 81 81 81 81 81 81 81 81 81 81 ...
##  $ DamID   : Factor w/ 91 levels &amp;quot;12G000K052&amp;quot;,&amp;quot;12G000K097&amp;quot;,..: 81 81 81 81 81 81 81 81 81 81 ...
##  $ PopID   : Factor w/ 4 levels &amp;quot;Pop1&amp;quot;,&amp;quot;Pop2&amp;quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ FamilyID: Factor w/ 105 levels &amp;quot;13F1306003&amp;quot;,&amp;quot;13F1306004&amp;quot;,..: 6 6 6 6 6 6 6 6 6 6 ...
##  $ SexID   : Factor w/ 2 levels &amp;quot;Female&amp;quot;,&amp;quot;Male&amp;quot;: 2 2 1 1 1 2 1 2 2 1 ...
##  $ TankID  : Factor w/ 2 levels &amp;quot;T1&amp;quot;,&amp;quot;T2&amp;quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ M1BW    : num  8.13 8.13 8.13 8.13 8.13 8.55 8.55 8.55 8.55 8.55 ...
##  $ M2BW    : num  29 30.5 33.3 40.1 43 29.1 30.7 30.7 32.5 35.6 ...
##  $ M2Age   : int  219 219 219 219 219 219 219 219 219 219 ...
##  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=shrimp,aes(x=PopID,y=M2BW,color=PopID)) + 
  geom_boxplot(outlier.size = 0)+
  geom_jitter(alpha=0.3)+
  labs(x=&amp;quot;群体&amp;quot;,y=&amp;quot;收获体重&amp;quot;)+
  theme_gray(base_size = 20)+
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:popbw&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-12-09-lmm-tutorial-2_files/figure-html/popbw-1.png&#34; alt=&#34;四个对虾群体收获体重的箱形图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: 四个对虾群体收获体重的箱形图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从上图中，大致可以看出，群体间是存在差异的。&lt;/p&gt;
&lt;p&gt;进一步分析数据，你会发现每个群体由多个家系组成，见下图。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=shrimp,aes(x=PopID,y=M2BW,fill=FamilyID)) + 
  geom_boxplot(outlier.size = 0)+
  labs(x=&amp;quot;群体&amp;quot;,y=&amp;quot;收获体重&amp;quot;)+
  theme_gray(base_size = 20)+
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:popfamilybw&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-12-09-lmm-tutorial-2_files/figure-html/popfamilybw-1.png&#34; alt=&#34;四个对虾群体内家系收获体重的箱形图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: 四个对虾群体内家系收获体重的箱形图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这里遇到了一个问题，在评价群体间的差异时，是否需要考虑每个群体内的家系结构？&lt;/p&gt;
&lt;p&gt;理论上，我们从每个群体抽样时，抽样个体是代表该群体的随机样本。但是，一个群体内的个体往往存在亲缘关系，譬如（全同胞、半同胞个体）。因此抽样个体存在两个层次：每个群体包括多个家系，每个家系包括数量不等的个体。&lt;/p&gt;
&lt;p&gt;从上图中可以看出，每个群体内的不同家系间是存在差异的。&lt;/p&gt;
&lt;p&gt;每一个家系内的个体，遗传自同一对亲本，相互间相似性更强。不同家系个体的体重均值是不一样的。&lt;/p&gt;
&lt;p&gt;这实际上&lt;strong&gt;违背了样本观察值的独立性原则&lt;/strong&gt;，同一个家系内的全同胞个体的体重值实际上是由他们亲本所决定。&lt;/p&gt;
&lt;p&gt;针对这种情况，我们把家系效应作为随机效应加入模型中。这相当于，给每个家系设置一个基线，类似于不同的家系有不同的平均体重，也称作&lt;strong&gt;随机截距（random intercept）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在模型中加入家系随机效应，那么观察值的非独立性问题就解决了。&lt;/p&gt;
&lt;p&gt;为了说明家系结构对分析结果的影响，故意在每个群体中设置了一个均值特别高的家系。在实际测试数据中，这种现象也会经常出现。如果我们分析时不考虑群体内的家系结构，那么家系方差会被累加到残差方差中。&lt;/p&gt;
&lt;p&gt;如果采取方差分析的方法，你也会发现，忽略家系结构，群体的均方值可能会&lt;strong&gt;非常大，被严重高估&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据教程1对于固定效应和随机效应的讨论，由于我们的目的是要分析四个群体间的差异，获得每个群体的性能，因此群体更适合做固定效应。每个群体是由多个家系组成的，这些家系只是大量家系的一个随机抽样，因此更加适合作为随机效应。&lt;/p&gt;
&lt;p&gt;下边我们通过两个模型实例，来看一下家系结构对分析结果的影响。&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;8&#34;&gt;模型8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Pop + Sex + Tank + Sex:M1BW\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#8&#34;&gt;模型8&lt;/a&gt;不考虑家系结构，Pop、Sex和Tank为固定效应，Sex:M1BW为协变量。&lt;/p&gt;
&lt;p&gt;分析结果如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.8 &amp;lt;- lm(M2BW ~ 1 + PopID + SexID + TankID + SexID:M1BW,shrimp)
summary(shrimp.lm.8) #加载lmerTest包后，lmer的返回结果，每个固定效应系数带有P值&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ 1 + PopID + SexID + TankID + SexID:M1BW, 
##     data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -20.7242  -2.5787  -0.2092   2.2353  18.9070 
## 
## Coefficients:
##                  Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)      35.42932    0.53924  65.702  &amp;lt; 2e-16 ***
## PopIDPop2        -1.61211    0.18406  -8.759  &amp;lt; 2e-16 ***
## PopIDPop3        -3.61817    0.18086 -20.005  &amp;lt; 2e-16 ***
## PopIDPop4        -5.76930    0.21237 -27.166  &amp;lt; 2e-16 ***
## SexIDMale        -5.39346    0.70557  -7.644 2.59e-14 ***
## TankIDT2         -2.93073    0.13206 -22.192  &amp;lt; 2e-16 ***
## SexIDFemale:M1BW  0.40396    0.06778   5.960 2.73e-09 ***
## SexIDMale:M1BW    0.30223    0.07363   4.105 4.13e-05 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.296 on 4233 degrees of freedom
##   (41 observations deleted due to missingness)
## Multiple R-squared:  0.4845, Adjusted R-squared:  0.4837 
## F-statistic: 568.4 on 7 and 4233 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(shrimp.lm.8) #lmerTest包提供该函数&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table
## 
## Response: M2BW
##              Df Sum Sq Mean Sq  F value    Pr(&amp;gt;F)    
## PopID         3  23856    7952  430.856 &amp;lt; 2.2e-16 ***
## SexID         1  39588   39588 2144.973 &amp;lt; 2.2e-16 ***
## TankID        1   9106    9106  493.407 &amp;lt; 2.2e-16 ***
## SexID:M1BW    2    889     445   24.095 3.934e-11 ***
## Residuals  4233  78124      18                       
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a id=&#34;9&#34;&gt;模型9&lt;/a&gt;考虑家系结构，Pop:Family为随机效应，Pop、Sex和Tank为固定效应，Sex:M1BW为协变量。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Pop + Sex + Tank + Sex:M1BW + Pop:Family\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在模型中加入随机效应，需要使用lme4包中的lmer函数。下边代码中的(1|PopID:FamilyID)，表示针对不同的家系，单独估计其随机截距（random intercept）。其中1表示随机截距。&lt;/p&gt;
&lt;p&gt;分析结果如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.9 &amp;lt;- lmer(M2BW ~ 1 + PopID + SexID + TankID + SexID:M1BW  + (1|PopID:FamilyID),shrimp)
summary(shrimp.lm.9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Linear mixed model fit by REML t-tests use Satterthwaite approximations
##   to degrees of freedom [lmerMod]
## Formula: 
## M2BW ~ 1 + PopID + SexID + TankID + SexID:M1BW + (1 | PopID:FamilyID)
##    Data: shrimp
## 
## REML criterion at convergence: 23070.4
## 
## Scaled residuals: 
##     Min      1Q  Median      3Q     Max 
## -5.5304 -0.5854  0.0240  0.6388  3.8977 
## 
## Random effects:
##  Groups         Name        Variance Std.Dev.
##  PopID:FamilyID (Intercept)  5.933   2.436   
##  Residual                   12.527   3.539   
## Number of obs: 4241, groups:  PopID:FamilyID, 105
## 
## Fixed effects:
##                   Estimate Std. Error        df t value Pr(&amp;gt;|t|)    
## (Intercept)        35.7188     1.0605  487.0000  33.683  &amp;lt; 2e-16 ***
## PopIDPop2          -1.6596     0.6884  101.0000  -2.411  0.01774 *  
## PopIDPop3          -3.7742     0.6733  102.0000  -5.606 1.78e-07 ***
## PopIDPop4          -5.8638     0.7359  111.0000  -7.968 1.58e-12 ***
## SexIDMale          -5.6599     0.5901 4148.0000  -9.591  &amp;lt; 2e-16 ***
## TankIDT2           -2.9491     0.1097 4140.0000 -26.884  &amp;lt; 2e-16 ***
## SexIDFemale:M1BW    0.3757     0.1204  993.0000   3.122  0.00185 ** 
## SexIDMale:M1BW      0.2904     0.1231 1068.0000   2.360  0.01847 *  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Correlation of Fixed Effects:
##             (Intr) PpIDP2 PpIDP3 PpIDP4 SxIDMl TnIDT2 SIDF:M
## PopIDPop2   -0.384                                          
## PopIDPop3   -0.419  0.506                                   
## PopIDPop4   -0.519  0.476  0.494                            
## SexIDMale   -0.248  0.002  0.007 -0.004                     
## TankIDT2    -0.042 -0.006 -0.004 -0.001 -0.030              
## SxIDFm:M1BW -0.889  0.077  0.108  0.250  0.291 -0.010       
## SxIDMl:M1BW -0.711  0.074  0.100  0.246 -0.352  0.010  0.786&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova(shrimp.lm.9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Variance Table of type III  with  Satterthwaite 
## approximation for degrees of freedom
##            Sum Sq Mean Sq NumDF  DenDF F.value    Pr(&amp;gt;F)    
## PopID       914.2   304.7     3  103.8   24.33  5.33e-12 ***
## SexID      1152.4  1152.4     1 4148.3   92.00 &amp;lt; 2.2e-16 ***
## TankID     9053.7  9053.7     1 4140.1  722.75 &amp;lt; 2.2e-16 ***
## SexID:M1BW  122.4    61.2     2 1414.2    4.88  0.007695 ** 
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把&lt;a href=&#34;#8&#34;&gt;模型8&lt;/a&gt;的Residual standard error的平方，与&lt;a href=&#34;#9&#34;&gt;模型9&lt;/a&gt; Random Effects部分对比，你会发现，如果不考虑家系结构，残差方差明显被高估,估计值为18.4559804 。考虑家系结构后，残差方差为12.5267428, 明显变小， 从残差中分离出了大部分的家系方差。由家系随机效应产生的方差，估计值为5.9328256，占表型方差的32%。&lt;/p&gt;
&lt;p&gt;从anova方差分析(如果对基础概念不了解，可参考这篇blog：&lt;a href=&#34;https://luansheng.netlify.com/post/df-and-anova/&#34;&gt;自由度和方差分析&lt;/a&gt;)的角度看，加入家系随机效应后，群体固定效应（PopID）尽管仍然也达到了显著水平，但是均方和F值明显变小。这表明存在这样一种风险，&lt;strong&gt;如果考虑群体内的家系结构，本来两个群体的差异可能达不到显著水平，但是如果忽视了这种家系结构，两个群体间的差异统计上会表现为显著水平&lt;/strong&gt;，从而误判群体间的实际性能差别。&lt;/p&gt;
&lt;p&gt;我们看一下，基于模型9（不包括家系的随机效应），预测四个群体家系的性能，如下图所示：你会发现，每个群体中特别大的家系效应，已经被剔除掉了。&lt;/p&gt;
&lt;p&gt;ps：拟合值反应的是包括所有固定和随机效应的结果，lmer中通过fitted()函数获得该值。预测值，是可以设定不包括随机效应的，lmer中通过predict()函数获得该值。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.9.predict &amp;lt;- predict(shrimp.lm.9,re.form=NA) #拟合值
shrimp.lm.9.predict.dt &amp;lt;- data.table(ObsSeq =as.integer(names(shrimp.lm.9.predict)),PredictedValue=shrimp.lm.9.predict)
shrimp[,&amp;quot;:=&amp;quot;(ObsSeq=seq(nrow(shrimp)))]
#把拟合值合并到shrimp数据集
shrimp.predicted.value &amp;lt;- merge(shrimp,shrimp.lm.9.predict.dt,by = c(&amp;quot;ObsSeq&amp;quot;),all.y = TRUE)



ggplot(data=shrimp.predicted.value,aes(x=PopID,y=PredictedValue,fill=FamilyID)) + 
  geom_boxplot(outlier.size = 0)+
  labs(x=&amp;quot;群体&amp;quot;,y=&amp;quot;收获体重预测值&amp;quot;)+
  theme_gray(base_size = 20)+
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:lm9fittedvalue&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-12-09-lmm-tutorial-2_files/figure-html/lm9fittedvalue-1.png&#34; alt=&#34;四个对虾群体体重的预测值&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: 四个对虾群体体重的预测值
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.5 随机效应的显著性检验&lt;/h3&gt;
&lt;p&gt;模型中加入随机效应后，如何检验其显著性？&lt;/p&gt;
&lt;p&gt;一般是通过似然比率检验（Likelihood ratio test, LRT)来实现。lmerTest包中的rand()函数提供该功能。&lt;/p&gt;
&lt;p&gt;首先我们来看一下似然比率检验的结果：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rand(shrimp.lm.9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Analysis of Random effects Table:
##                Chi.sq Chi.DF p.value    
## PopID:FamilyID   1341      1  &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;卡方检验表明，&lt;em&gt;p&lt;/em&gt;&amp;lt;0.01，模型中加入PopID:Family随机效应后，对样本数据拟合得更好。&lt;/p&gt;
&lt;p&gt;LRT检验的公式为&lt;span class=&#34;math inline&#34;&gt;\(LR = 2*(lnL1 - lnL2)\)&lt;/span&gt;，其中L1为复杂模型的最大似然值，L2为简单模型的最大似然值。对L1和L2分别取log转换，计算LR值。然后通过卡方检验，确定p值。自由度为复杂模型和简单模型包括的随机效应数之差。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#9&#34;&gt;模型9&lt;/a&gt;的最大似然值log转换后为：&lt;span class=&#34;math inline&#34;&gt;\(-1.153518\times 10^{4}\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;不包括PopID:Family随机效应的&lt;a href=&#34;#8&#34;&gt;模型8&lt;/a&gt;的logLikelihood值为&lt;span class=&#34;math inline&#34;&gt;\(-1.21958\times 10^{4}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;lmer函数返回的最大似然值log转换通过lme4包的logLik()函数实现。对于lm函数返回的最大似然值，stats包也有对应的logLik()函数处理。&lt;/p&gt;
&lt;p&gt;似然比率为：LR = 2*(-11535.178901292 - -12195.7957678913) = 1321.23。自由度为1。&lt;/p&gt;
&lt;p&gt;跟直接利用rand()函数获得的卡方值相比略有出入。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.5 获得每个群体的性能&lt;/h3&gt;
&lt;p&gt;调用emmeans包中的函数，计算四个群体的估计边际均值(estimated marginal means)，或者说最小二乘均值(least-squares means)。根据边际均值，我们可以对群体的性能进行排序和比较。&lt;/p&gt;
&lt;p&gt;关于emmeans包，请参考日志&lt;a href=&#34;http://luansheng.netlify.com/post/least-squares-means-note-1/&#34;&gt;最小二乘均值的估计模型&lt;/a&gt;。尽管该日志介绍的是lsmeans包，但用法跟emmeans包都是一样的。而且根据作者介绍，在不久的将来，emmeans包要替代lsmeans包。&lt;/p&gt;
&lt;p&gt;注意，安装emmeans还需要pbkrtest包，这个包没有自动安装，需要手动安装。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(emmeans)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: emmeans&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: package &amp;#39;emmeans&amp;#39; was built under R version 3.4.3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &amp;#39;emmeans&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &amp;#39;package:lmerTest&amp;#39;:
## 
##     lsmeans&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm9.rgl &amp;lt;- ref_grid(shrimp.lm.9)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required namespace: pbkrtest&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Note: D.f. calculations have been disabled because the number of observations exceeds 3000.
## To enable adjustments, set emm_options(pbkrtest.limit = 4241) or larger,
## but be warned that this may result in large computation time and memory use.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;emmeans(shrimp.lm9.rgl,&amp;quot;PopID&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  PopID   emmean        SE  df asymp.LCL asymp.UCL
##  Pop1  33.83782 0.4853477 Inf  32.88656  34.78909
##  Pop2  32.17826 0.4903717 Inf  31.21715  33.13937
##  Pop3  30.06359 0.4659862 Inf  29.15028  30.97691
##  Pop4  27.97398 0.5373764 Inf  26.92074  29.02722
## 
## Results are averaged over the levels of: SexID, TankID 
## Degrees-of-freedom method: asymptotic 
## Confidence level used: 0.95&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上边结果中查找emmean列，可以看到Pop1群体的边际均值最大，这表明四个群体中该群体性能最好。&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>线性混合效应模型教程1</title>
      <link>/post/lmm-tutorial-1/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/lmm-tutorial-1/</guid>
      <description>&lt;p&gt;学习线性混合效应模型（Linear Mixed Effects Model，LMM）最好的方法，是一边学习理论，一边动手实践，这样印象最为深刻。 本文参考了Bodo Winter博士的教程Linear models and linear mixed effects models in R&lt;a href=&#34;http://www.bodowinter.com/tutorial/bw_LME_tutorial1.pdf&#34;&gt;教程1&lt;/a&gt;&lt;a href=&#34;http://www.bodowinter.com/tutorial/bw_LME_tutorial2.pdf&#34;&gt;教程2&lt;/a&gt;的结构。&lt;/p&gt;
&lt;p&gt;本文中，为了便于理解，使用的数据集是来自csv文件&lt;a href=&#34;https://luansheng.netlify.com/post/shrimp.csv&#34;&gt;shrimp&lt;/a&gt;中的对虾育种数据（对原始数据已经进行了变换）。&lt;/p&gt;
&lt;p&gt;推荐使用&lt;a href=&#34;https://www.rstudio.com/products/RStudio/&#34;&gt;Rstudio&lt;/a&gt;来运行&lt;a href=&#34;https://www.r-project.org/&#34;&gt;R&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文代码使用了四个包，请提前加载。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data.table1&lt;/li&gt;
&lt;li&gt;ggplot2&lt;/li&gt;
&lt;li&gt;lme4&lt;/li&gt;
&lt;li&gt;sjPlot&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加载方法：可以在控制台（console）运行&lt;code&gt;require(data.table)&lt;/code&gt;命令，加载data.table包。其他包加载命令类似。&lt;/p&gt;
&lt;p&gt;初学者提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R代码和shrimp.csv最好保存在同一个路径下，譬如c:&lt;/li&gt;
&lt;li&gt;设置工作路径到c:，&lt;code&gt;setwd(&amp;quot;c:/shrimp&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1 读取数据文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fread()&lt;/code&gt;函数来自data.table包，特点是对大文件读取速度特别快。建议使用data.table作为数据处理的主力包。&lt;/p&gt;
&lt;p&gt;其中的参数sep表示文件是用逗号分割，header表示数据文件中第一行是列名，stringsAsFactors表示读入的数据，对于字符类型，是否自动处理为因子类型。为了方便后边模型处理，这里设置为因子类型。&lt;/p&gt;
&lt;p&gt;str()函数可以对数据集有一个汇总。从中看可以看出，AnimalID-个体编号，SireID-父本编号，DamID-母本编号，FamilyID-家系编号，SexID-性别，TankID-测试池号等字符类型，已经被设置为因子类型了。M1BW-入池前体重，M2BW-收获体重和M2Age-收获时日龄均为数字变量。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp &amp;lt;- fread(input = &amp;quot;shrimp.csv&amp;quot;,sep = &amp;quot;,&amp;quot;,header = TRUE,stringsAsFactors = TRUE)
str(shrimp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;data.table&amp;#39; and &amp;#39;data.frame&amp;#39;:   4282 obs. of  10 variables:
##  $ AnimalID: Factor w/ 4282 levels &amp;quot;13G1000001&amp;quot;,&amp;quot;13G1000002&amp;quot;,..: 3308 3307 2215 1303 3601 2184 2194 2175 1585 2176 ...
##  $ SireID  : Factor w/ 100 levels &amp;quot;12G000K010&amp;quot;,&amp;quot;12G000K065&amp;quot;,..: 81 81 81 81 81 81 81 81 81 81 ...
##  $ DamID   : Factor w/ 91 levels &amp;quot;12G000K052&amp;quot;,&amp;quot;12G000K097&amp;quot;,..: 81 81 81 81 81 81 81 81 81 81 ...
##  $ PopID   : Factor w/ 4 levels &amp;quot;Pop1&amp;quot;,&amp;quot;Pop2&amp;quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ FamilyID: Factor w/ 105 levels &amp;quot;13F1306003&amp;quot;,&amp;quot;13F1306004&amp;quot;,..: 6 6 6 6 6 6 6 6 6 6 ...
##  $ SexID   : Factor w/ 2 levels &amp;quot;Female&amp;quot;,&amp;quot;Male&amp;quot;: 2 2 1 1 1 2 1 2 2 1 ...
##  $ TankID  : Factor w/ 2 levels &amp;quot;T1&amp;quot;,&amp;quot;T2&amp;quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ M1BW    : num  8.13 8.13 8.13 8.13 8.13 8.55 8.55 8.55 8.55 8.55 ...
##  $ M2BW    : num  29 30.5 33.3 40.1 43 29.1 30.7 30.7 32.5 35.6 ...
##  $ M2Age   : int  219 219 219 219 219 219 219 219 219 219 ...
##  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据文件准备完毕，我们正式开始学习线性混合效应模型。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2 引子：线性混合效应模型可以做什么&lt;/h2&gt;
&lt;p&gt;我们从一个简单的问题开始。对虾是有性别的，分雌雄。如果你对对虾没有任何了解，你可能会想知道，雄虾和雌虾的体重差别大吗？&lt;/p&gt;
&lt;p&gt;我们测定了4282尾虾的体重。&lt;/p&gt;
&lt;p&gt;我们首先直观的看一下雌雄虾体重分布点图。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=shrimp,aes(x=SexID,y=M2BW,color=SexID))+geom_boxplot()+geom_dotplot(binaxis = &amp;quot;y&amp;quot;,stackdir = &amp;quot;center&amp;quot;,position = &amp;quot;dodge&amp;quot;,binwidth = 0.25)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:sexdotplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/sexdotplot-1.png&#34; alt=&#34;雌雄虾体重分布点图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: 雌雄虾体重分布点图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从图1中可以大体看出，雌虾体重比雄虾高。然后，我们实际计算雌雄虾体重均值，发现雌虾的确比雄虾重。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.sex.m2bw &amp;lt;- shrimp[,mean(M2BW,na.rm=TRUE),by=.(SexID)]
shrimp.sex.m2bw&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     SexID       V1
## 1:   Male 28.16273
## 2: Female 34.37646&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们不禁要问，雌雄虾的这个差别是真实的吗？这是雌雄虾体重真正的差值吗？这个结果有没有偏差？&lt;/p&gt;
&lt;p&gt;分析一下数据，你会发现，雌雄虾分布在2多个测试池中，且来自105个家系，并且每个家系的入池体重是存在差别的。而且你会发现，两个池子的养殖管理水平存在较大差别。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(shrimp,aes(x=TankID,y=M2BW,color=TankID))+geom_boxplot()+geom_dotplot(binaxis = &amp;quot;y&amp;quot;,stackdir = &amp;quot;center&amp;quot;,position = &amp;quot;dodge&amp;quot;,binwidth = 0.3)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:tankdotplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/tankdotplot-1.png&#34; alt=&#34;不同测试池体重分布点图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: 不同测试池体重分布点图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们需要去除测试池、家系对雌雄虾体重的影响，准确估计雌雄虾体重。接下来就要用到线性模型了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3 线性混合效应模型简介&lt;/h2&gt;
&lt;p&gt;&lt;a id=&#34;1&#34;&gt;模型1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + \varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表示一尾虾的体重由性别和随机误差决定。其中&lt;span class=&#34;math inline&#34;&gt;\(Sex\)&lt;/span&gt;作为固定效应，&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt;作为随机效应。后者表示所有影响体重的不可测量的效应总和，是随机和不可控制的。&lt;/p&gt;
&lt;p&gt;从数据中我们发现，一尾虾的体重还受它所在的测试池和所在家系的影响。因此，这两个效应也需要放到模型中。模型进一步变为：&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;2&#34;&gt;模型2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + Tank +\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;3&#34;&gt;模型3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + Tank + Family +\varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;新加入的两个变量，Tank和Family，如果都作为固定效应。那么上述模型称为线性模型。如果Family作为随机效应，那么模型3称为线性混合效应模型（固定效应+随机效应）。&lt;/p&gt;
&lt;p&gt;这里碰到的一个棘手问题是，模型中一个效应到底是作为固定效应，还是随机效应？准确的说，应该是与研究目的相关。&lt;/p&gt;
&lt;p&gt;SAS for Mixed models (Second edition) 手册中对固定效应的定义为：“An effect is called fixed if the levels in the study represent all possible levels of the factor, or at least all levels about which inference is to be made”。可简单地理解为“该效应的所有水平在实验群体中都已经出现”。譬如在本数据集中，性别只有雌、雄两个水平，因此模型中性别一般作为固定效应。再比如，测试投喂5种饲料对对虾体重的影响。由于目的很明确，只是评估这5种饲料的差异，因此饲料应作为固定效应。&lt;/p&gt;
&lt;p&gt;随机效应的定义为：“Factor effects are random if they are used in the study to represent only a sample (ideally, a random sample) of a larger set of potential levels”。可简单地理解为“试验群体出现的该效应的水平只是一个很大水平数中的随机抽样。&lt;/p&gt;
&lt;p&gt;固定效应和随机效应的差别在哪里？“一个效应作为固定效应，还是随机效应，应该依据研究的目的而定”。“a factor is considered random if its levels plausibly represent a larger population with a probability distribution”。如果我们分析一个效应的目的是为了研究它所在的一个具有概率分布的大群体的情况，那么这个效应应该作为随机效应。随机效应有两个特点，a) 它是大群体中的一个样本，b) 它具有概率分布。&lt;/p&gt;
&lt;p&gt;譬如在shrimp数据集中，我们当前的目的是分析雌雄两个性别的体重差异，那么105个家系就是很大家系中的一个小样本，因此作为随机效应更为合适。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;4 线型混合效应模型R实战分析&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.1 简单线性模型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lm()&lt;/code&gt;是R自带的函数。&lt;code&gt;summary()&lt;/code&gt;函数输出shrimp.lm的结果。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm &amp;lt;- lm(M2BW~SexID,shrimp)
shrimp.lm.sum &amp;lt;- summary(shrimp.lm)
shrimp.lm.sum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ SexID, data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -22.9765  -3.1765  -0.0765   3.0235  18.9235 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  34.3765     0.1082  317.65   &amp;lt;2e-16 ***
## SexIDMale    -6.2137     0.1560  -39.82   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 5.101 on 4280 degrees of freedom
## Multiple R-squared:  0.2704, Adjusted R-squared:  0.2702 
## F-statistic:  1586 on 1 and 4280 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在解释上边的结果。首先来看&lt;code&gt;Multiple R-squared:&lt;/code&gt; 0.2703699，它表示模型对总体方差的解释能力。具体意思可以解释为，总体方差中的27.04%，可以由这个模型来解释。&lt;code&gt;Adjusted R-squared&lt;/code&gt;是对&lt;code&gt;Multiple R-squared&lt;/code&gt;的矫正，主要是考虑了固定效应。固定效应越多，该值越低。&lt;/p&gt;
&lt;p&gt;下一个概念是非常的重要，那就是p值。P值是否小于0.05或者0.001，已经成为文章结果是否可靠，是否能够发表的一个重要标志。但是，p值一定程度上就像SCI论文的影响因子，有点滥用的味道。Nature上关于p值的故事:&lt;a href=&#34;http://blog.sciencenet.cn/blog-265205-771680.html&#34;&gt;中文版本&lt;/a&gt;；&lt;a href=&#34;http://www.nature.com/news/scientific-method-statistical-errors-1.14700&#34;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们还本溯源，本质上p值是一个条件概率，它表示&lt;strong&gt;无效假设为真时的概率&lt;/strong&gt;。那什么是无效假设呢？在上文中，无效假设是&lt;strong&gt;“对于体重性状，雌雄虾间没有差异”&lt;/strong&gt;，也就是说雌雄虾体重是相等的。在本文中，p值为&amp;lt;0.001 ，意味着如果”雌雄间没有差异，那么数据基本上不可能是这样“，因为&lt;strong&gt;雌雄间没有差异&lt;/strong&gt;的概率太低！这反过来表明，性别影响了对虾的体重，雌雄虾体重是有差别的，也就是说统计上是显著的。&lt;/p&gt;
&lt;p&gt;需要注意的另外一个问题是，模型所有效应的显著性（最底部）与系数列表单个效应的显著性还是存在差别的。上文中，两个结果是一致的，主要是因为模型中只包括1个固定效应。如果有更多效应，这两个值就不再相等。&lt;/p&gt;
&lt;p&gt;F值是我们应该关注的另外一个参数，表示模型是否显著的一个重要参数。F值可以简单理解为处理方差与误差方差的比值，譬如在上文中，可以理解为性别间体重方差与残差方差的比值，这个值越大，那么表示雌雄间体重差异越大。需要注意，在上文中F值是1928，与两个自由度有关系（性别2-1；误差4281-1）。&lt;/p&gt;
&lt;p&gt;接下来重点讨论系数列表。你会看到SexIDMale，你可能会问，SexID有两个水平，Female去哪里了？Estimates这一列表示的固定效应值到底是什么意思？&lt;/p&gt;
&lt;p&gt;需要注意，系数列表中最后一列p值，表示估计值偏离0的程度。&lt;/p&gt;
&lt;p&gt;首先看一下系数列表中的(Intercept) 项，估计值是34.3764626，是不是感觉很熟悉？它是Female体重的均值。在本文前边我们估计了雌雄体重的均值。&lt;/p&gt;
&lt;p&gt;再看一下SexIDMale的估计值，是-6.2137345。Intercept估计值+SexIDMale估计值=雄虾体重值28.1627282。为什么要用雌虾体重值作为截距？为什么雄虾体重固定效应估计值要表示为与截距，也就是雌虾体重值的差值？&lt;/p&gt;
&lt;p&gt;第一个问题，之所以选择雌虾而不是雄虾作为截距，只是因为Female和Male这两个水平Female根据字母排序在Male前边。&lt;/p&gt;
&lt;p&gt;第二个问题，之所以把雄虾体重固定效应值表示为与截距之差，是为了与协变量等统一起来。为了解释，大家先看图。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sex.bw &amp;lt;- shrimp[,mean(M2BW,na.rm=TRUE),by=.(SexID)]

ggplot(data=shrimp,aes(x=SexID,y=M2BW,color=SexID))+
  geom_dotplot(binaxis = &amp;quot;y&amp;quot;,stackdir = &amp;quot;center&amp;quot;,position = &amp;quot;dodge&amp;quot;,binwidth = 0.25)+
  geom_vline(xintercept = 1)+
  geom_vline(xintercept = 2)+
  geom_hline(yintercept = 33.93992)+
  geom_hline(yintercept = 27.77438)+
  geom_abline(intercept = 40.75,slope=-6.6155)+
  geom_text(x=2.4,y=31.5,label=&amp;quot;-6.6155&amp;quot;)+
  annotate(&amp;quot;segment&amp;quot;,x=2.5,xend=2.5,y=27.77438,yend = 33.93992)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:sexdotplotannotation&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/sexdotplotannotation-1.png&#34; alt=&#34;雌雄虾体重截距分解&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 3: 雌雄虾体重截距分解
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为Female和Male均为因子变量，因此在x轴上可以将Female标准化为0，Male与Female的间距为1，二者体重差值为-6.2137345，那么斜线的斜率可以认为等于-6.2137345。这样就可以很方便的求解或者说预测体重。&lt;/p&gt;
&lt;p&gt;我们可以根据&lt;a href=&#34;#1&#34;&gt;模型1&lt;/a&gt;，预测雌雄虾体重：&lt;/p&gt;
&lt;p&gt;我们随机选取一尾虾，如果是雄虾，那么斜率为-6.2137345，雄虾的预测体重为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(BW = 群体均值 + 雄虾的固定效应\)&lt;/span&gt; = 34.3764626462644 + -6.21373449092449 = 28.1627282&lt;/p&gt;
&lt;p&gt;我们随机选取一尾虾，如果是雌虾，因为截距本身设置为雌虾体重均值，因此斜率为0，雌虾的预测体重为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(BW = 群体均值 + 雌虾的固定效应\)&lt;/span&gt; = 34.3764626462644 + 0*1 = 34.3764626&lt;/p&gt;
&lt;p&gt;我们继续来看一个稍微复杂的例子，在模型中加入TankID效应&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.sex.tank &amp;lt;- lm(M2BW~SexID+TankID,shrimp)
shrimp.lm.sex.tank.sum &amp;lt;- summary(shrimp.lm.sex.tank)
shrimp.lm.sex.tank.sum&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ SexID + TankID, data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -21.4916  -3.0478  -0.1697   2.8166  20.4084 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  35.8560     0.1276  281.10   &amp;lt;2e-16 ***
## SexIDMale    -6.2082     0.1493  -41.58   &amp;lt;2e-16 ***
## TankIDT2     -2.9644     0.1492  -19.87   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.882 on 4279 degrees of freedom
## Multiple R-squared:  0.332,  Adjusted R-squared:  0.3317 
## F-statistic:  1063 on 2 and 4279 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上边模型中可以看出，截距是35.8560193。我们把数据汇总一下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp[,mean(M2BW,na.rm=TRUE),by=.(SexID,TankID)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     SexID TankID       V1
## 1:   Male     T1 29.62356
## 2: Female     T1 35.87844
## 3:   Male     T2 26.70756
## 4: Female     T2 32.86907&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们发现，模型实际上是把Female.T1这个组合均值设置为截距（群体均值）。Male到Female.T1的斜率为-6.2081881，T2到Female.T1的斜率为-2.9644499；同理，Female到Female.T1的斜率为0，T1到Female.T1的斜率也为0。&lt;/p&gt;
&lt;p&gt;那么，根据&lt;a href=&#34;#2&#34;&gt;模型2&lt;/a&gt;,可以预测雌雄虾体重：&lt;/p&gt;
&lt;p&gt;如果随机从T1池捞取一尾雄虾，它的预测体重为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(BW = 群体均值 + 雄虾的固定效应 + T1池固定效应\)&lt;/span&gt; = 35.856019327243 + -6.2081881124781*1 + 0*1 = 29.6478312&lt;/p&gt;
&lt;p&gt;这个数值跟Male.T1的均值非常接近。&lt;/p&gt;
&lt;p&gt;如果随机从T2池捞取一尾雄虾，它的预测体重为&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(BW = 群体均值 + 雄虾的固定效应 + T2池固定效应\)&lt;/span&gt; = 35.856019327243 + -6.2081881124781*1 + -2.96444990544144*1 = 26.6833813&lt;/p&gt;
&lt;p&gt;这个数值跟Male.T2的均值非常接近。&lt;/p&gt;
&lt;p&gt;如果随机从T2池捞取一尾雌虾，它的预测体重为&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(BW = 群体均值 + 雌虾的固定效应 + T2池固定效应\)&lt;/span&gt; = 35.856019327243 + 0*1 + -2.96444990544144*1 = 32.8915694&lt;/p&gt;
&lt;p&gt;这个数值跟Female.T2的均值非常接近。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.2 带协变量的线性模型&lt;/h3&gt;
&lt;p&gt;什么是协变量（covariate)？ wikipedia中是这样解释&lt;a href=&#34;https://en.wikipedia.org/wiki/Covariate&#34;&gt;协变量&lt;/a&gt;的：In statistics, a covariate is a variable that is possibly predictive of the outcome under study. A covariate may be of direct interest or it may be a confounding or interacting variable. The alternative terms explanatory variable, independent variable, or predictor, are used in a regression analysis.&lt;/p&gt;
&lt;p&gt;举个简单例子，我们从每个家系选择选择30尾个体，尾部用VIE颜色标记后，混合养殖在一起，比较每个家系的生长性能。需要考虑的一个问题就是，混合养殖前每个家系的大小，是不一样的。一般，混养前体重越大的家系，混养结束时体重也会越大。我们在分析混养后体重时，需要考虑混养前每个家系体重对它的影响。这个混养前家系体重，就是一个协变量，在回归分析中，也会称为自变量，解释变量。&lt;/p&gt;
&lt;p&gt;计算每个家系的混养后平均收获体重（M2BW）&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.taggingbw.per.family &amp;lt;-  shrimp[,lapply(.SD,mean,na.rm=TRUE),by=.(FamilyID),.SDcols=c(&amp;quot;M1BW&amp;quot;,&amp;quot;M2BW&amp;quot;)]
shrimp.taggingbw.per.family&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        FamilyID     M1BW     M2BW
##   1: 13F1306014 8.503478 32.73478
##   2: 13F1306015 8.614000 36.00000
##   3: 13F1306016 8.753810 34.89286
##   4: 13F1306019 7.747561 34.25122
##   5: 13F1306022 8.931842 33.66842
##  ---                             
## 101: 13F1306802 7.274138 27.69655
## 102: 13F1367013 5.438571 25.70000
## 103: 13F1367075 5.016250 26.19750
## 104: 13F1367097 6.937500 26.18125
## 105: 13F1367106 9.000222 38.87778&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绘制出混养前家系初始体重（M1BW）和混养后体重的散点图（M2BW）：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=shrimp.taggingbw.per.family,aes(x=M1BW,y=M2BW))+
  geom_point()+
  geom_smooth(method = &amp;quot;lm&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:taggingbwbwpoint&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/taggingbwbwpoint-1.png&#34; alt=&#34;混养前家系初始体重和混养后体重的散点图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 4: 混养前家系初始体重和混养后体重的散点图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;很明显，二者表现为正相关，相关系数为0.39。因此在对比雌雄体重差异时，需要考虑加入M1BW作为协变量，对M2BW进行校正。&lt;/p&gt;
&lt;p&gt;分析下边2个模型：&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;4&#34;&gt;模型4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = M1BW + \varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.m1bw &amp;lt;- lm(M2BW ~ M1BW,shrimp)
summary(shrimp.lm.m1bw)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ M1BW, data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -20.6953  -4.1186  -0.3901   3.8326  21.3708 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept) 24.47899    0.47668   51.35   &amp;lt;2e-16 ***
## M1BW         0.94848    0.06434   14.74   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 5.832 on 4239 degrees of freedom
##   (41 observations deleted due to missingness)
## Multiple R-squared:  0.04876,    Adjusted R-squared:  0.04854 
## F-statistic: 217.3 on 1 and 4239 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边实际上是简单的回归分析，系数表中Intercept为24.4789861，表示当M1BW为0时，混养体重M2BW为24.4789861g。实际上初始体重不可能为0。因此这个截距没有实际意义。&lt;/p&gt;
&lt;p&gt;M1BW的系数估计值为0.9484804，表示初始体重每增加1g，混养体重会增加0.9484804g。&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;5&#34;&gt;模型5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + Sex:M1BW + \varepsilon\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.sex.m1bw &amp;lt;- lm(M2BW~SexID+SexID:M1BW,shrimp)
summary(shrimp.lm.sex.m1bw)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ SexID + SexID:M1BW, data = shrimp)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -23.719  -3.078  -0.090   2.846  18.417 
## 
## Coefficients:
##                  Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)      27.28624    0.54727  49.858  &amp;lt; 2e-16 ***
## SexIDMale        -5.91782    0.80948  -7.311 3.16e-13 ***
## SexIDFemale:M1BW  0.97548    0.07385  13.208  &amp;lt; 2e-16 ***
## SexIDMale:M1BW    0.93313    0.08053  11.587  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.933 on 4237 degrees of freedom
##   (41 observations deleted due to missingness)
## Multiple R-squared:  0.3196, Adjusted R-squared:  0.3191 
## F-statistic: 663.4 on 3 and 4237 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个模型稍微复杂一些。从系数列表中，针对雌性两个性别，给出了不同的回归系数。这主要是由于雌雄生长速度的差异造成的，后期雌虾生长速要快于雄虾。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=shrimp,aes(x=M1BW,y=M2BW,color=SexID))+geom_point()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Removed 41 rows containing missing values (geom_point).&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:taggingbwbwpointbysex&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/taggingbwbwpointbysex-1.png&#34; alt=&#34;雌雄虾混养前家系初始体重和混养后体重的散点图&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 5: 雌雄虾混养前家系初始体重和混养后体重的散点图
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们根据&lt;a href=&#34;#5&#34;&gt;模型5&lt;/a&gt;来预测一尾雄虾的体重,假定它的混养前体重为5g，那么它的混养后体重为26.0340769g。&lt;/p&gt;
&lt;p&gt;M2BW = 27.2862423952692 + -5.91782358698496 + 0.933131628220428*5 = 26.0340769g&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;4.3 包括交互效应的线性模型&lt;/h3&gt;
&lt;p&gt;模型已经变的越来越复杂了。我们进一步在&lt;a href=&#34;#5&#34;&gt;模型5&lt;/a&gt;中加入养殖池TankID效应。&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;6&#34;&gt;模型6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + Tank + Sex:M1BW\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.sex.tank.m1bw &amp;lt;- lm(M2BW ~ SexID + TankID + SexID:M1BW,shrimp)
shrimp.lm.sex.tank.m1bw.sum &amp;lt;- summary(shrimp.lm.sex.tank.m1bw)
print(shrimp.lm.sex.tank.m1bw.sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ SexID + TankID + SexID:M1BW, data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -22.2635  -2.9218  -0.1317   2.7273  19.9333 
## 
## Coefficients:
##                  Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)      28.59445    0.52621  54.340  &amp;lt; 2e-16 ***
## SexIDMale        -5.43136    0.77289  -7.027 2.44e-12 ***
## TankIDT2         -2.95103    0.14467 -20.399  &amp;lt; 2e-16 ***
## SexIDFemale:M1BW  0.99876    0.07049  14.168  &amp;lt; 2e-16 ***
## SexIDMale:M1BW    0.88930    0.07689  11.566  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.708 on 4236 degrees of freedom
##   (41 observations deleted due to missingness)
## Multiple R-squared:  0.3805, Adjusted R-squared:  0.3799 
## F-statistic: 650.4 on 4 and 4236 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从Adjusted R-squared参数（0.3798813 vs 0.2701994可以看出，模型6 对数据的解释能力，相比模型1，已经提高了。也就是说根据模型6预测体重，准确性比模型1要高。&lt;/p&gt;
&lt;p&gt;什么是交互效应？Interaction effects represent the combined effects of factors on the dependent measure. When an interaction effect is present, the impact of one factor depends on the level of the other factor。两个效应间相互影响，促进或者制约的关系。&lt;/p&gt;
&lt;p&gt;譬如，我们数据中有Sex和Tank两个固定效应，那么我们可能会想 雌虾会不会在特别偏爱某种环境，譬如在T1池中长得比T2池中大，但是雄虾可能会在T2池中长的比T1池大？因此我们可以在模型中试着加入交互效应。&lt;/p&gt;
&lt;p&gt;&lt;a id=&#34;7&#34;&gt;模型7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[M2BW = Sex + Tank + Sex:Tank + Sex:M1BW\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;shrimp.lm.sex.tank.m1bw.interaction &amp;lt;- lm(M2BW ~ SexID + TankID + SexID:TankID + SexID:M1BW,shrimp)
shrimp.lm.sex.tank.m1bw.interaction.sum &amp;lt;- summary(shrimp.lm.sex.tank.m1bw.interaction)
print(shrimp.lm.sex.tank.m1bw.interaction.sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = M2BW ~ SexID + TankID + SexID:TankID + SexID:M1BW, 
##     data = shrimp)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -22.2039  -2.8961  -0.1335   2.7157  19.9954 
## 
## Coefficients:
##                    Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)        28.64805    0.52985  54.068  &amp;lt; 2e-16 ***
## SexIDMale          -5.56393    0.78792  -7.062 1.92e-12 ***
## TankIDT2           -3.07193    0.20104 -15.280  &amp;lt; 2e-16 ***
## SexIDMale:TankIDT2  0.25075    0.28953   0.866    0.387    
## SexIDFemale:M1BW    0.99972    0.07050  14.180  &amp;lt; 2e-16 ***
## SexIDMale:M1BW      0.89123    0.07692  11.586  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 4.708 on 4235 degrees of freedom
##   (41 observations deleted due to missingness)
## Multiple R-squared:  0.3806, Adjusted R-squared:  0.3798 
## F-statistic: 520.4 on 5 and 4235 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从系数表中，可以看出，相比两个主效应（SexIDMale：-5.563925、TankIDT2：-3.0719274），Sex和Tank的交互效应非常小（0.2507485），p &amp;gt; 0.05，统计检验与0相比，达不到显著水平。Adjusted R-squared: 0.3798447也表明，相比&lt;a href=&#34;#6&#34;&gt;模型6&lt;/a&gt;，&lt;a href=&#34;#7&#34;&gt;模型7&lt;/a&gt;的解释能力并没有提高。&lt;/p&gt;
&lt;p&gt;我们图形展示一下模型7固定效应：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot_model(shrimp.lm.sex.tank.m1bw.interaction,show.values = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34; style=&#34;text-align: center&#34;&gt;&lt;span id=&#34;fig:lm4plot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-11-19-lmm-tutorial-1_files/figure-html/lm4plot-1.png&#34; alt=&#34;模型7固定效应图形展示&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 6: 模型7固定效应图形展示
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不考虑除残差外的随机效应，目前模型6是最优模型。我们根据&lt;a href=&#34;#6&#34;&gt;模型6&lt;/a&gt;，可以回答最初的问题，雌雄体重间差异显著。接下来，我们会考虑在模型中加入随机效应，进入线性混合效应模型部分。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>动物育种值预测中的线性模型学习笔记2</title>
      <link>/post/lmm-for-ebv-prediction-xfa/</link>
      <pubDate>Sat, 11 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/lmm-for-ebv-prediction-xfa/</guid>
      <description>&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;6.4.1 因子分析&lt;/h2&gt;
&lt;p&gt;设定w向量，包括n个变量，w的协方差矩阵为G，w用模型表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
w = \mu + \phi c + s
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;是群体均值，c是长度为m的公共因子向量，s是残差效应或特定效应，&lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt;是n×m阶因子负荷矩阵。FA最为常见的形式，是&lt;span class=&#34;math inline&#34;&gt;\(\phi\)&lt;/span&gt;中的任意两列是正交的(orthogonal)，也就是说&lt;span class=&#34;math inline&#34;&gt;\(\phi_{i}\phi_{j}=0\)&lt;/span&gt;，其中i≠j。c中的公共因子不相关，并且方差为1，&lt;span class=&#34;math inline&#34;&gt;\(var(c)=I\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;w的协方差矩阵，可以分解为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[var(w) = G_{FA}=\phi\phi^{&amp;#39;} + S\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>FA和XFA学习笔记</title>
      <link>/post/fa-xfa-note/</link>
      <pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/fa-xfa-note/</guid>
      <description>&lt;p&gt;ASReml中有一个XFA方差结构。本文从FA(因子分析)基础入手，做一个有关FA和XFA的学习笔记。目的是，弄清楚在ASReml中如何定义XFA方差结构。以及如何解读生成的方差组分。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1 因子分析的基本概念&lt;/h2&gt;
&lt;p&gt;因子分析(factor analysis)是一种数据简化的技术。它通过研究众&lt;strong&gt;多变量&lt;/strong&gt;之间的内部依赖关系（这里指的变量是譬如&lt;strong&gt;体长、体重、头胸甲等性状&lt;/strong&gt;，而不是样品编号），探求观测数据中的&lt;strong&gt;基本结构&lt;/strong&gt;，并用少数几个&lt;strong&gt;基础变量&lt;/strong&gt;（underlying variate）来表示其基本的数据结构。这几个基础变量能够反映原来众多变量的主要信息。原始的变量是可观测的变量，而基础变量是不可观测的潜在变量，称为&lt;strong&gt;因子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因子分析实际上是降维的一种方法。&lt;/p&gt;
&lt;p&gt;譬如：在企业形象或品牌形象的研究中，消费者可以通过一个有24个指标构成的评价体系，评价百货商场的24个方面的优劣。但消费者主要关心的是三个方面，即商店的环境、商店的服务和商品的价格。因子分析方法可以通过24个变量，找出反映商店环境、商店服务水平和商品价格的4个公共潜在的因子，对商店进行综合评价。而这4个公共因子可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
x_{i}=\mu_{i}+\alpha_{i1}F_{1}+\alpha_{i2}F_{2}+\alpha_{i3}F_{3}+\alpha_{i4}F_{4}+\varepsilon_{i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下边对上述模型的解释尤为重要,提到了两个非常重要的概念，&lt;strong&gt;公共因子&lt;/strong&gt;和&lt;strong&gt;特殊因子&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;math inline&#34;&gt;\(x_{i}\)&lt;/span&gt;表示每个指标（变量），F1，F2，F3和F4表示不可观测的4个公共因子，24个指标（变量）共享这4个因子，每个指标（变量）中不能被共享的部分，称为特殊因子&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{i}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因子分析与主成分分析的异同（最好有实际的例子展示）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主成分分析: 初始变量的线性组合表示新的综合变量，即主成分；&lt;/li&gt;
&lt;li&gt;因子分析：潜在的基础变量即公共变量和特殊变量的线性组合表示原始变量；&lt;/li&gt;
&lt;li&gt;主成分分析仅仅是变量转换，而因子分析需要构造因子分析模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2 因子分析的数学模型&lt;/h2&gt;
&lt;p&gt;首先来看一个数学模型：&lt;/p&gt;
&lt;p&gt;模型的方式表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
X = \mu + AF + \varepsilon
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中X为观测变量矩阵, A为载荷因子矩阵，F为公共因子矩阵，&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt;为特殊因子矩阵。&lt;/p&gt;
&lt;p&gt;矩阵形式表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{bmatrix}
x_{1} \\ 
x_{2} \\ 
...   \\
x_{p}
\end{bmatrix} 
= 
\begin{bmatrix}
\mu_{1} \\ 
\mu_{2} \\ 
...     \\
\mu_{p}
\end{bmatrix}
+
\begin{bmatrix}
\alpha_{11} &amp;amp; \alpha_{12} &amp;amp; ... &amp;amp; \alpha_{1m} \\ 
\alpha_{21} &amp;amp; \alpha_{22} &amp;amp; ... &amp;amp; \alpha_{2m} \\ 
\vdots      &amp;amp; \vdots      &amp;amp; \vdots &amp;amp; \vdots   \\ 
\alpha_{p1} &amp;amp; \alpha_{p2} &amp;amp; ... &amp;amp; \alpha_{pm}
\end{bmatrix}
\begin{bmatrix}
F_{1} \\ 
F_{2} \\ 
...   \\
F_{m}
\end{bmatrix}
+
\begin{bmatrix}
\varepsilon_{1} \\ 
\varepsilon_{2} \\ 
...     \\
\varepsilon_{p} 
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上边这个模型中，&lt;span class=&#34;math inline&#34;&gt;\(x_{p}\)&lt;/span&gt;表示第p个可观察的变量，对应到例子中24个指标(p=24)；m表示公共因子的数量，对应到上边的例子，m=4；&lt;span class=&#34;math inline&#34;&gt;\(a_{pm}\)&lt;/span&gt;称为因子载荷矩阵，p行m列，对应到例子为24行4列；&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon_{p}\)&lt;/span&gt;表示特殊因子，对应到例子中24个指标(p=24)。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.3 因子分析模型的一些性质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;公共因子和特殊因子之间独立，协方差为0，不相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
cov(F,\varepsilon) = 0
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公共因子间不相关，每个因子的方差为1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
D(F) = 
\begin{bmatrix}
1 &amp;amp;   &amp;amp;   &amp;amp;   \\ 
  &amp;amp; 1 &amp;amp;   &amp;amp;   \\ 
  &amp;amp;   &amp;amp; \ddots &amp;amp;   \\ 
  &amp;amp;   &amp;amp;   &amp;amp; 1
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊因子间不相关，每个因子的方差可以不等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
D(\varepsilon) = 
\begin{bmatrix}
\sigma^2_{1} &amp;amp;   &amp;amp;   &amp;amp;   \\ 
  &amp;amp; \sigma^2_{2} &amp;amp;   &amp;amp;   \\ 
  &amp;amp;   &amp;amp; \ddots &amp;amp;   \\
  &amp;amp;   &amp;amp;   &amp;amp; \sigma^2_{p} 
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始变量协方差结构的分解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
X - \mu =  AF + \varepsilon
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Var(X-\mu) = AVar(F)A + Var(\varepsilon) \\
Var(X) = AVar(F)A + Var(\varepsilon)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上边这个公式非常重要，它表明X的协方差矩阵可以表示用公共因子方差矩阵、载荷系数矩阵和特殊因子矩阵进行表示。这几个矩阵的维度比X的协方差矩阵都要低很多。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;xfa-extended-factor-analysis-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.4 XFA (eXtended Factor Analysis model)&lt;/h2&gt;
&lt;p&gt;XFA实际上是因子分析的一种扩展形式，参见&lt;a href=&#34;https://www.vsni.co.uk/software/asreml/htmlhelp/asreml/facanal.htm&#34;&gt;ASReml的说明文档&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;譬如xfa1(4)表示，原始变量有4个，公共因子只有1个，载荷系数矩阵为4行×1列，特殊因子为4行×1列。 当时给ASReml作者Arthur Gilmour的邮件中也是这么理解的：&lt;/p&gt;
&lt;p&gt;Now I have known some about XFA and what you have write. XFA1 means that we only use the 1 common factor. I also know the number of parameters will be 8 (the first four values are for special or residual variance, the last four values are the coefficient for 1th common factor ) if I have 4 variables.&lt;/p&gt;
&lt;p&gt;在ASReml中定义方差结构时，如果需要提供先验值，以XFA1(4)为例，那么顺序是：4个特殊因子方差值；然后是载荷系数矩阵第1列（4个数，只有1列），如果是xfa2(4)，那么这里会有8个数（因为有2列）。&lt;/p&gt;
&lt;p&gt;以直接DGE和间接遗传效应IGE方差组分为例，如果有高（HD）和低（LD）2个密度，那么会存在四个变量：LD.DGE、LD.IGE HD.DGE HD.IGE，在ASReml中可以这样定义：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str(Dens.AnimalID $Mates Zero.Animal xfa1(4).nrm(AnimalID))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;Mates&lt;/code&gt;表示为(实际上是2个密度的IGE)：&lt;/p&gt;
&lt;pre class=&#34;asreml&#34;&gt;&lt;code&gt;!ASSIGN Mates Dens.Mate1 and(Dens.Mate2) and(Dens.Mate3) and(Dens.Mate4) and(Dens.Mate5) and(Dens.Mate6) and(Dens.Mate7) and(Dens.Mate8) and(Dens.Mate9) and(Dens.Mate10) and(Dens.Mate11) and(Dens.Mate12) and(Dens.Mate13) and(Dens.Mate14) and(Dens.Mate15) and(Dens.Mate16) and(Dens.Mate17) and(Dens.Mate18) and(Dens.Mate19) and(Dens.Mate20) and(Dens.Mate21) and(Dens.Mate22) and(Dens.Mate23) and(Dens.Mate24) and(Dens.Mate25) and(Dens.Mate26) and(Dens.Mate27) and(Dens.Mate28) and(Dens.Mate29) and(Dens.Mate30) and(Dens.Mate31) and(Dens.Mate32) and(Dens.Mate33) and(Dens.Mate34) and(Dens.Mate35) and(Dens.Mate36) and(Dens.Mate37) and(Dens.Mate38) and(Dens.Mate39) and(Dens.Mate40) and(Dens.Mate41) and(Dens.Mate42) and(Dens.Mate43) and(Dens.Mate44) and(Dens.Mate45)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中Zero.Animal的意思，咨询ASReml的作者Arthur Gilmour：&lt;/p&gt;
&lt;p&gt;只是说The design matrix for an XFA terms needs extra empty columns to fit the FACTOR.&lt;/p&gt;
&lt;p&gt;ASReml给出的一个结果：&lt;/p&gt;
&lt;pre class=&#34;asreml&#34;&gt;&lt;code&gt;4 XFA_V  0  1  0.257662      0.257662       0.43   0 P  
4 XFA_V  0  2   0.00000       0.00000       0.00   0 F  
4 XFA_V  0  3   0.00000       0.00000       0.00   0 F  
4 XFA_V  0  4  0.676462E-03  0.676462E-03   0.70   0 P  
4 XFA_L  1  1 -0.650819     -0.650819      -1.80   0 P  
4 XFA_L  1  2  0.894162      0.894162       4.18   0 P    
4 XFA_L  1  3  0.468200E-01  0.468200E-01   1.88   0 P  
4 XFA_L  1  4 -0.126477E-01 -0.126477E-01  -0.90   0 P  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前边四个值是特殊因子方差，接下来四个值是因子载荷矩阵第1列的四个值。&lt;/p&gt;
&lt;p&gt;ASReml提供了从xfa到us结构的转换方法（在VPREDICT部分）：&lt;/p&gt;
&lt;pre class=&#34;asreml&#34;&gt;&lt;code&gt;VPREDICT !DEFINE
V Gen xfa1(4).nrm(AnimalID) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转换为us结构后的结果(10个参数，4行×4列下三角)：&lt;/p&gt;
&lt;pre class=&#34;asreml&#34;&gt;&lt;code&gt; AnimalID               NRM   13176
  13 Gen                      0.68124       0.42820        
  14 Gen                     -0.58188       0.33805        
  15 Gen                      0.79961       0.44647        
  16 Gen                     -0.30467E-01   0.28622E-01    
  17 Gen                      0.41867E-01   0.27579E-01
  18 Gen                      0.21921E-02   0.24696E-02
  19 Gen                      0.82304E-02   0.11226E-01
  20 Gen                     -0.11310E-01   0.14198E-01
  21 Gen                     -0.59218E-03   0.78588E-03
  22 Gen                      0.83648E-03   0.10994E-02&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;todo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;todo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;因子载荷矩阵，需要详细了解。以及在ASRreml中为什么需要zero。&lt;/li&gt;
&lt;li&gt;关于XFA，在Linear Models for the Prediction of Animal Breeding Values(3nd version)中，有讨论，可以深入看一下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table学习笔记5</title>
      <link>/post/data-table-note-5/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-table-note-5/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;data.table的特点：&lt;strong&gt;减小计算复杂度&lt;/strong&gt;，降低&lt;strong&gt;计算时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;dfdata.framedtdata.table&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1. 1建立两个数据集：DF（data.frame）和DT（data.table）&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DF = data.frame(x=rep(c(&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;),each=3), y=c(1,3,6), v=1:9) #data frame类型数据集
DT = data.table(x=rep(c(&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;),each=3), y=c(1,3,6), v=1:9) #data.table类型数据集&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;dfdtidentical&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2 比较DF和DT,注意函数identical，是比较两个对象的安全方式。&lt;/h2&gt;
&lt;p&gt;DF和DT本质上都是list类型？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DF&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   x y v
## 1 b 1 1
## 2 b 3 2
## 3 b 6 3
## 4 a 1 4
## 5 a 3 5
## 6 a 6 6
## 7 c 1 7
## 8 c 3 8
## 9 c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: b 3 2
## 3: b 6 3
## 4: a 1 4
## 5: a 3 5
## 6: a 6 6
## 7: c 1 7
## 8: c 3 8
## 9: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;identical(dim(DT),dim(DF)) #比较维数是否相同&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;identical(DF$a,DT$a) #比较a列是否相同&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.list(DF) #检测是否是list类型&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.list(DT) #同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;is.data.frame(DT) #data.table是否是data.frame类型&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tables() #用来统计全局环境中有多少个data.table。&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      NAME NROW NCOL MB COLS  KEY
## [1,] DT      9    3  1 x,y,v    
## Total: 1MB&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.3 基本数据提取操作&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[2] #提取第2行&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[3:2] #提取第3行和第2行&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 6 3
## 2: b 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[order(x)] #根据x列排序DT数据集&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6
## 4: b 1 1
## 5: b 3 2
## 6: b 6 3
## 7: c 1 7
## 8: c 3 8
## 9: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[order(x),] #同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6
## 4: b 1 1
## 5: b 3 2
## 6: b 6 3
## 7: c 1 7
## 8: c 3 8
## 9: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[y&amp;gt;2] #提取y&amp;gt;2的所有数据行&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 3 2
## 2: b 6 3
## 3: a 3 5
## 4: a 6 6
## 5: c 3 8
## 6: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[y&amp;gt;2 &amp;amp; v&amp;gt;5] #提取满足条件y&amp;gt;2 并且v&amp;gt;5的所有数据行&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 6 6
## 2: c 3 8
## 3: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[!2:4] #剔除2,3,4行后的数据集&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: a 3 5
## 3: a 6 6
## 4: c 1 7
## 5: c 3 8
## 6: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[-(2:4)] #同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: a 3 5
## 3: a 6 6
## 4: c 1 7
## 5: c 3 8
## 6: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.4 选择列，计算列&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,v] #选择v列返回向量&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,list(v)] #同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    v
## 1: 1
## 2: 2
## 3: 3
## 4: 4
## 5: 5
## 6: 6
## 7: 7
## 8: 8
## 9: 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,.(v)] #同上，.()等同于list()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    v
## 1: 1
## 2: 2
## 3: 3
## 4: 4
## 5: 5
## 6: 6
## 7: 7
## 8: 8
## 9: 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(v)] #计算v列的和，返回一个向量&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,.(sum(v))] #同上，但是返回一个data.table类型，列名V1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    V1
## 1: 45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,.(sv=sum(v))] #同上，命名为sv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    sv
## 1: 45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,.(v,v*2)] #生成一个新的数据集，包括v和v*2两列&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    v V2
## 1: 1  2
## 2: 2  4
## 3: 3  6
## 4: 4  8
## 5: 5 10
## 6: 6 12
## 7: 7 14
## 8: 8 16
## 9: 9 18&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.5 同时筛选行列&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[2:3,sum(v)] #返回一个向量&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[2:3,.(sum(v))] #返回一个data.table,列命名为V1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    V1
## 1:  5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[2:3,.(sv=sum(v))] #返回一个data.table，列命名为sv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    sv
## 1:  5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[2:5,cat(v,&amp;quot;\n&amp;quot;)] #v列2-5行，通过cat连接输出为一个字符串，不明白为什么有一个NULL&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2 3 4 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data.frame&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.6 通过data.frame的方式提取数据&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,2,with=FALSE] #提取2列的数据，with参数，控制列是否可以运算&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    y
## 1: 1
## 2: 3
## 3: 6
## 4: 1
## 5: 3
## 6: 6
## 7: 1
## 8: 3
## 9: 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(2),with=FALSE] #with=FALSE，表示列不可运算，返回与上式相同的结果&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    y
## 1: 1
## 2: 3
## 3: 6
## 4: 1
## 5: 3
## 6: 6
## 7: 1
## 8: 3
## 9: 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(v),with=TRUE] #v列之和&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#DT[,sum(v),with=FALSE] #这种格式错误，不能操作v列
DT[[&amp;quot;v&amp;quot;]] #提取v列更快的方式&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.7 组操作&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(v),by=x] #依据x列分组，求v列和&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: b  6
## 2: a 15
## 3: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(v),keyby=x] #依据x列分组，求v列和，结果按照x列排序&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: a 15
## 2: b  6
## 3: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[,sum(v),keyby=x][order(x)] #结果同上，但是链式表达式操作&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: a 15
## 2: b  6
## 3: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.8 快速数据集提取，二级索引形式&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[&amp;quot;a&amp;quot;,on=&amp;quot;x&amp;quot;] #on开启二级索引形式&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[&amp;quot;a&amp;quot;,on=.(x)] #更加方便的形式，不用写双引号&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;a&amp;quot;),on=.(x)] #作用同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[x==&amp;quot;a&amp;quot;] #on 传统形式，然而内部进行了优化，速度同上&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[x!=&amp;quot;b&amp;quot; | y!=3] #没有进行优化&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: b 6 3
## 3: a 1 4
## 4: a 3 5
## 5: a 6 6
## 6: c 1 7
## 7: c 3 8
## 8: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,3),on=c(&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;)] #二级索引优化&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,3),on=.(x,y)] #二级索引，简化去除引号&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 3 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,1:2),on=.(x,y)] #不匹配的返回NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y  v
## 1: b 1  1
## 2: b 2 NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,1:2),on=.(x,y),nomatch=0] #不匹配的行，不返回&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,1:2),on=.(x,y),roll=Inf] #不匹配的行，返回前边行对应的值&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: b 2 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;,1:2),on=.(x,y),roll=-Inf] #不匹配的行，返回后边行对应的值&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: b 2 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[.(&amp;quot;b&amp;quot;),sum(v*y),on=&amp;quot;x&amp;quot;] #提取x==&amp;quot;b&amp;quot;的行，计算v*y的值，然后求和&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 25&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.9 综合以上所有技能&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[x!=&amp;quot;a&amp;quot;,sum(v),by=x] #对照&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: b  6
## 2: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[!&amp;quot;a&amp;quot;,sum(v),by=.EACHI,on=&amp;quot;x&amp;quot;] #结果同上，速度更快 .EACHI的意思就是对i中的每一个水平分组分组&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: b  6
## 2: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[c(&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;),sum(v),by=.EACHI,on=.(x)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: b  6
## 2: c 24&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.10 合并数据集&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT #原始数据集&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: b 1 1
## 2: b 3 2
## 3: b 6 3
## 4: a 1 4
## 5: a 3 5
## 6: a 6 6
## 7: c 1 7
## 8: c 3 8
## 9: c 6 9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;X = data.table(x=c(&amp;quot;c&amp;quot;,&amp;quot;b&amp;quot;),v=8:7,foo=c(4,2)) #X作为拟要合并的数据集
X&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x v foo
## 1: c 8   4
## 2: b 7   2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;X[DT,on=&amp;quot;x&amp;quot;] #以DT数据集中x列为主，筛选与之匹配的X中的行，left join&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x  v foo y i.v
## 1: b  7   2 1   1
## 2: b  7   2 3   2
## 3: b  7   2 6   3
## 4: a NA  NA 1   4
## 5: a NA  NA 3   5
## 6: a NA  NA 6   6
## 7: c  8   4 1   7
## 8: c  8   4 3   8
## 9: c  8   4 6   9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=&amp;quot;x&amp;quot;] #以X数据集中x列为主，筛选与之匹配的DT行 right join&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.v foo
## 1: c 1 7   8   4
## 2: c 3 8   8   4
## 3: c 6 9   8   4
## 4: b 1 1   7   2
## 5: b 3 2   7   2
## 6: b 6 3   7   2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=&amp;quot;x&amp;quot;,nomatch=0] #返回双方共有的行 inner join&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.v foo
## 1: c 1 7   8   4
## 2: c 3 8   8   4
## 3: c 6 9   8   4
## 4: b 1 1   7   2
## 5: b 3 2   7   2
## 6: b 6 3   7   2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[!X,on=&amp;quot;x&amp;quot;] #返回的是X中没有的DT数据集中的行&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v
## 1: a 1 4
## 2: a 3 5
## 3: a 6 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=.(y&amp;lt;=foo)] #从此一下的表达式不是特别理解&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.x i.v
## 1: b 4 1   c   8
## 2: a 4 4   c   8
## 3: c 4 7   c   8
## 4: b 4 2   c   8
## 5: a 4 5   c   8
## 6: c 4 8   c   8
## 7: b 2 1   b   7
## 8: a 2 4   b   7
## 9: c 2 7   b   7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=.(y&amp;gt;=foo)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.x i.v
## 1: b 4 3   c   8
## 2: a 4 6   c   8
## 3: c 4 9   c   8
## 4: b 2 2   b   7
## 5: a 2 5   b   7
## 6: c 2 8   b   7
## 7: b 2 3   b   7
## 8: a 2 6   b   7
## 9: c 2 9   b   7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=.(x,y&amp;lt;=foo)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.v
## 1: c 4 7   8
## 2: c 4 8   8
## 3: b 2 1   7&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,.(x,y,x.y,v),on=.(x,y&amp;gt;foo)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y x.y v
## 1: c 4   6 9
## 2: b 2   3 2
## 3: b 2   6 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=&amp;quot;x&amp;quot;,mult=&amp;quot;first&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.v foo
## 1: c 1 7   8   4
## 2: b 1 1   7   2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,on=&amp;quot;x&amp;quot;,mult=&amp;quot;last&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y v i.v foo
## 1: c 6 9   8   4
## 2: b 6 3   7   2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,sum(v),by=.EACHI,on=&amp;quot;x&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: c 24
## 2: b  6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,sum(v)*foo,by=.EACHI,on=&amp;quot;x&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x V1
## 1: c 96
## 2: b 12&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X,sum(v)*i.v,by=.EACHI,on=&amp;quot;x&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x  V1
## 1: c 192
## 2: b  42&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT[X, on=.(x, v&amp;gt;=v), sum(y)*foo, by=.EACHI]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x v V1
## 1: c 8 36
## 2: b 7 NA&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>动物育种值预测中的线性模型学习笔记1</title>
      <link>/post/lmm-for-ebv-prediction-note-1/</link>
      <pubDate>Thu, 20 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/lmm-for-ebv-prediction-note-1/</guid>
      <description>&lt;div id=&#34;-genetic-evaluation-with-different-sources-of-records&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;第一章 基于不同来源记录的遗传评估(Genetic evaluation with different sources of records)&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1 介绍&lt;/h2&gt;
&lt;p&gt;育种值预测是大部分为了遗传改良而建立的育种程序不可或缺的一部分。准确地预测育种值，关键是能够获得哪些记录。在一个群体中，开始阶段能够获得的是个体记录，这些个体间可能存在亲缘关系，也可能不存在。在随后的世代中，后代和其他亲缘个体记录也会不断获的。因此，一开始可以用于育种值预测的主要是个体记录，以及少数亲属个体。在本章中，主要讨论利用个体记录以及来自其他亲缘信息预测育种值。此外（also），也讨论了复合不同来源和亲属信息计算选择指数的方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2 基础模型&lt;/h2&gt;
&lt;p&gt;环境和遗传因素决定动物个体的每一个表型观测值。因此可以通过1.1模型对表型观测值进行分解：&lt;/p&gt;
&lt;p&gt;表型观测值=环境效应+遗传效应+残差效应&lt;/p&gt;
&lt;p&gt;用公式书写为：&lt;/p&gt;
&lt;p&gt;模型1.1&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
y_{ij}=\mu_{i}+g_{i}+e_{ij}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(y_{ij}\)&lt;/span&gt;表示第&lt;span class=&#34;math inline&#34;&gt;\(i^{th}\)&lt;/span&gt;个体的第j个测定记录；&lt;span class=&#34;math inline&#34;&gt;\(\mu_{i}\)&lt;/span&gt;表示可剖分的非随机环境效应，主要是指固定效应，如窝组、出生年份、性别等；&lt;span class=&#34;math inline&#34;&gt;\(g_{i}\)&lt;/span&gt;是个体i基因型的加性（&lt;span class=&#34;math inline&#34;&gt;\(g_{a}\)&lt;/span&gt;）、显性(&lt;span class=&#34;math inline&#34;&gt;\(g_{d}\)&lt;/span&gt;)和上位epitatic(&lt;span class=&#34;math inline&#34;&gt;\(g_{e}\)&lt;/span&gt;)遗传效应；&lt;span class=&#34;math inline&#34;&gt;\(e_{ij}\)&lt;/span&gt;是影响个体i的随机环境效应之和。&lt;/p&gt;
&lt;p&gt;上文中的加性遗传值（&lt;span class=&#34;math inline&#34;&gt;\(g_{a}\)&lt;/span&gt;），指的是个体来自父本和母本基因的加性效应均值，被称为育种值（breeding value）。*&lt;strong&gt;每个亲本贡献自身基因的一半给它的后代&lt;/strong&gt;。亲本传递给后代的一半基因，其多次抽样的均值，称作该亲本的传递能力（&lt;strong&gt;transmitting ability&lt;/strong&gt;），是该亲本加性遗传值的一半。因此后代育种值等于其双亲传递能力之和。 因为加性遗传值是从亲本传递给子代的基因的函数，它是仅有的可以选择的元素（相对于显性和上位）。显性和上位表示位点内、位点间的交互，通常假定这些效应很少是显著的，一般包括&lt;span class=&#34;math inline&#34;&gt;\(e^{*}_{ij}\)&lt;/span&gt;效应中。因此模型1.1可以改写为：&lt;/p&gt;
&lt;p&gt;模型1.2&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
y_{ij}=\mu+g_{ai}+e^{*}_{ij}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&#34;math inline&#34;&gt;\(e^{*}_{ij}\)&lt;/span&gt;表示随机环境效应、显性和上位遗传值之和。模型1.2形式，适用于动物育种大部分育种值预测问题。通常假定y符合多变量正态分布，这其中的含义表示性状是有无数个加性基因决定，每个基因的效应是相同并且微小的，并且这些基因分布在非连锁位点上，也就是通常说的&lt;strong&gt;微效多基因模型&lt;/strong&gt;（infinitesimal model）。并且，进一步假定y、g和e的方差var(y)、var(g)、&lt;span class=&#34;math inline&#34;&gt;\(var(e^{*}\)&lt;/span&gt;)是已知的,并且配对个体间不存在任何相关（&lt;span class=&#34;math inline&#34;&gt;\(cov(e^{*},e^{*})=0\)&lt;/span&gt;）（不是特别理解）。而且，&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;代表在相同的管理组下所有个体的平均性能，例如在同一个管理系统下，相同的年龄和性别，因此假定&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;也是已知的。那么问题就简单了，从模型1.2中，可以看出，预测育种值的问题，已经简化为&lt;strong&gt;根据剖分出的非随机环境效应调整表型观测值问题，近似等于加权动物个体和他们的亲缘个体的测定记录&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据前边的解释，个体i的育种值&lt;span class=&#34;math inline&#34;&gt;\(a_{i}\)&lt;/span&gt;可以进一步剖分：&lt;/p&gt;
&lt;p&gt;公式1.3&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
a_{i}=g_{ai}=\frac{1}{2}a_{s}+\frac{1}{2}a_{d}+m_{i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(a_{s}\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(a_{d}\)&lt;/span&gt;分别表示父本和母本的育种值，&lt;span class=&#34;math inline&#34;&gt;\(m_{i}\)&lt;/span&gt;是个体i的育种值与双亲育种值均值的偏差，也就是孟德尔抽样(Mendelian sampling)。从遗传上分析（inheritance），孟德尔抽样的本质，是由于每一个亲本仅仅从它的基因库中随机抽取了一半给它的后代（基于染色体的分离和自由组合规律，个体的一半基因，会有很多种组合）。因此，一对父母产生的后代，其基因肯定不会完全相同，他们之间存在着遗传变异。孟德尔抽样，可以理解为，个体来自双亲的加性基因的均值（父母本平均，不是基因平均）与来自双亲的所有可能后代的均值之差。&lt;/p&gt;
&lt;p&gt;在育种程序中，准确地预测育种值是非常重要的。因为在遗传改良过程中，必须要准确地选择那些真正属于高育种值的个体。根据可以用来进行选择的候选个体的类型和可以利用的信息，来决定使用何种预测育种值的方法。下一步讨论，如何利用不同的信息来源预测育种值。在许多遗传评估应用案例中，出现的PTA（predicted tranmitting ability）或者说ETA（estimated transmitting ability），通常指的是预测育种值的一半。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.3 利用动物自身性能预测育种值&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.3.1 单次记录&lt;/h3&gt;
&lt;p&gt;对于个体，当仅可获得一个表型值记录时，个体i的估计育种值计算公式为:&lt;/p&gt;
&lt;p&gt;公式1.4&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\hat{a}_{i} = b(y_{i}-\mu)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中b是真实育种值对表型性能的回归系数；&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; 是群体均值，假定&lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;是已知的。&lt;/p&gt;
&lt;p&gt;公式1.5&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ b = \frac{cov(a,y)}{var(y)} = \frac{cov(a,a+e)}{var(y)} \\
= \frac{\sigma^2_{a}}{\sigma^2_{y}} \\
= h^2
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;预测值等于调整后的记录值乘以遗传力。选择标准间的相关，在这个例子中是真实育种值与表型值间的相关，也称作预测的准确度。预测准确度，提供了一种评估不同选择标准的方法：相关度越高，选择标准更加适合用来预测育种值。在某些情况下，重复力（repeatability, &lt;span class=&#34;math inline&#34;&gt;\(r^2\)&lt;/span&gt;）也可以作为评估准确性的参数。当个体仅有一个观测值时，准确度计算公式为：&lt;/p&gt;
&lt;p&gt;公式1.6&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,y} = cov(a,y)/(\sigma_{a}\sigma_{y}) \\
= \sigma^{2}_{a}/(\sigma_{a}\sigma_{y}) \\
= h
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;准确度为遗传力的开方。选择反应的计算公式（Falconer and Mackay, 1996）为:&lt;/p&gt;
&lt;p&gt;公式1.7&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
R = ir^{2}_{a,y}\sigma_{y} = ih^{2}\sigma_{y}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，i称作选择强度（selection intensity），以表型标准差为单位，表示选择个体超过群体均值的程度。&lt;/p&gt;
&lt;p&gt;育种值的方差（&lt;span class=&#34;math inline&#34;&gt;\(var(\hat{a}_{i})\)&lt;/span&gt;）表示为:&lt;/p&gt;
&lt;p&gt;公式1.8&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
var(\hat{a}_{i}) = var(by) = var(h^{2}y) \\
= h^{4}\sigma^{2}_{y} \\
= r^{2}_{a,y}h^{2}\sigma^{2}_{y} \\
= r^{2}_{a,y}\sigma^{2}_{a}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例1.1 一窝小母牛的一周岁体重均值为250kg，该性状的遗传力为0.45，如果其中一头小母牛周岁重320kg，请问它的育种值是多少？育种值估计的准确度是多少？&lt;/p&gt;
&lt;p&gt;根据公式1.4，育种值计算为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\hat{a}_{i} = 0.45*(320-250) =\)&lt;/span&gt; 31.5kg。&lt;/p&gt;
&lt;p&gt;育种值估计的准确度(根据公式1.6计算)&lt;/p&gt;
&lt;p&gt;$r_{a,y} = $ 0.67。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;1.3.2 重复记录&lt;/h3&gt;
&lt;p&gt;个体的多次测定记录，如奶牛在哺乳期的多次产奶量，其均值可以用来预测个体的育种值。对于个体的多次测定记录，通常会存在如下假定：由于受到环境因子或者永久影响个体多次测定记录的环境的影响，多次测定记录间会存在更多的相似性（additional resemblance）。换句话说（in other words），受非遗传永久环境效应的影响，个体的多次测定记录间存在额外的协方差。&lt;/p&gt;
&lt;p&gt;个体间的方差可以进一步剖分为部分遗传的和部分环境的方差（永久环境效应，permanent environmental effect）；个体内的方差组分，是由对个体进行多次测量时的临时环境差异引起的。因此，观测值的方差可以进一步剖分为：&lt;/p&gt;
&lt;p&gt;公式1.9&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[var(y) = var(g) + var(pe) + var(te)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;math inline&#34;&gt;\(var(g)\)&lt;/span&gt;是加性和非加性遗传方差；&lt;span class=&#34;math inline&#34;&gt;\(var(pe)\)&lt;/span&gt;是由永久环境效应产生的方差；&lt;span class=&#34;math inline&#34;&gt;\(var(te)\)&lt;/span&gt;是由随机的(random) 临时的 (temporary) 环境效应引起的方差。&lt;/p&gt;
&lt;p&gt;组内相关（&lt;strong&gt;组内个体间的相关&lt;/strong&gt;），指的是个体间方差与表型方差的比例(the ratio of between-individual variance to phenotypic variance)&lt;/p&gt;
&lt;p&gt;公式1.10&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[t=(var(g)+var(pe))/var(y)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;t通常称之为重复力，用来测量个体记录间的相关。&lt;/p&gt;
&lt;p&gt;从公式1.10也可以反推出&lt;/p&gt;
&lt;p&gt;公式1.11&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[var(te)/var(y) = 1-t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于公式1.10 ，通常会假设重复记录是来自同一个性状，也就是说任何成对记录间的遗传相关应该是1（&lt;strong&gt;不是太理解&lt;/strong&gt;）。另外一个假设是：所有的测定记录，具有相同的方差。并且所有成对记录的环境相关是相同的。设定&lt;span class=&#34;math inline&#34;&gt;\(\tilde{y}\)&lt;/span&gt;表示个体i的n个记录的均值。个体i的育种值可以通过公式1.12进行预测：&lt;/p&gt;
&lt;p&gt;公式1.12&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\hat{a}_{i} = b(\tilde{y}_{i}-\mu)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对上述公式进行推导：&lt;/p&gt;
&lt;p&gt;公式1.13&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[b = cov(a,\tilde{y})/var(\tilde{y})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;体重a指的是真实育种值。进一步分解&lt;span class=&#34;math inline&#34;&gt;\(cov(a,\tilde{y})\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;公式1.14&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[cov(a,\tilde{y}) = cov(a,g + pe + \sum{te}/n) = \sigma^{2}_{a}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之所以能够推导出上述公式，是因为a与pe、te之间不存在相关性，所以他们的协方差为零。&lt;/p&gt;
&lt;p&gt;公式1.15&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[var(\tilde{y}) = var(g) + var(pe) +var(te)/n\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于&lt;span class=&#34;math inline&#34;&gt;\(var(\tilde{y})\)&lt;/span&gt;，不同于&lt;span class=&#34;math inline&#34;&gt;\(var(y)\)&lt;/span&gt;,最后te的方差需要除以n。&lt;/p&gt;
&lt;p&gt;根据公式1.10 和公式1.11可以对公式1.15进一步变换：&lt;/p&gt;
&lt;p&gt;公式1.16（注意，原书中这个地方写错了，写成var(t)了）&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
var(\tilde{y}) = var(g) + var(pe) + (1-t)\frac{var(y)}{n} \\
= var(y)t + (1-t)\frac{var(y)}{n} \\
=var(y)(t + \frac{1-t}{n}) \\
=\sigma^{2}_{y}(t + \frac{1-t}{n})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据公式1.16，那么公式1.13可以进一步简化为：&lt;/p&gt;
&lt;p&gt;公式1.17&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
b = cov(a,\tilde{y})/var(\tilde{y}) \\
= \frac{\sigma^{2}_{a}}{\sigma^{2}_{y}(t + \frac{1-t}{n})} \\
= \frac{\sigma^{2}_{a}}{\sigma^{2}_{y}}\frac{1}{t + \frac{1-t}{n}} \\
= h^{2}\frac{1}{\frac{nt+1-t}{n}} \\
= h^{2}\frac{1}{\frac{1+(n-1)t}{n}} \\
= h^{2}n\frac{1}{1+(n-1)t} \\
= \frac{nh^{2}}{1+(n-1)t} \\
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;公式可以看出b由&lt;strong&gt;遗传力、重复力和记录的重复测量次数&lt;/strong&gt;决定。从公式1.12中，可以推出，也意味着育种值由上述三个参数决定。&lt;/p&gt;
&lt;p&gt;就像前边提到的，假定个体重复记录的差别是由于测量连续性能（successive performance）时的现场环境差异（temporary environment）造成的。如果清楚那些影响性能的因子，会对连续记录产生影响，那么必须要进行校正。&lt;/p&gt;
&lt;p&gt;譬如，第一次和第二次哺乳期（lactation）产仔（calving）时的母牛年龄，会影响两次哺乳期的产奶量 （milk yield）。因此应用两次哺乳期产奶量均值，预测育种值时，必须要对这种年龄差异进行矫正。&lt;/p&gt;
&lt;p&gt;育种值的准确性用公式（1.18）表述为：&lt;/p&gt;
&lt;p&gt;公式1.18 （基于公式1.16和1.17）&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,\tilde{y}} = \frac{cov(a,\tilde{y})}{\sigma_{a}\sigma_{\tilde{y}}} \\
= \frac{\sigma^{2}_{a}}{\sigma_{a}\sqrt{\sigma^{2}_{y}(t + \frac{1-t}{n})}} \\
= \frac{\sigma_{a}}{\sqrt{\sigma^{2}_{y}(t + \frac{1-t}{n})}} \\
= \frac{\sigma_{a}}{\sigma_{y}\sqrt{t + \frac{1-t}{n}}} \\
= \frac{h}{\sqrt{t + \frac{1-t}{n}}} \\
= h\sqrt{\frac{n}{nt +1-t}} \\
= \sqrt{\frac{nh^{2}}{1+(n-1)t}} \\
= \sqrt{b}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;与单性状的记录相比，多次记录其育种值估计的准确度更好，受重复力和测定记录次数影响。育种值预测准确度的提高，主要来自于当测定记录次数增加时，测定时环境方差（个体内方差）的降低。从公示1.16就可以看出。当n不断增大时，&lt;span class=&#34;math inline&#34;&gt;\(\sigma^{2}_{y}(t + \frac{1-t}{n})\)&lt;/span&gt;是不断减小的。当重复力较低时，增加测定记录次数，可以显著的提高预测准确度。&lt;/p&gt;
&lt;p&gt;譬如假定&lt;span class=&#34;math inline&#34;&gt;\(h^{2}\)&lt;/span&gt;=0.3, t=0.5，当n=1, 2, 6, 10时，育种值估计的准确度分别为&lt;/p&gt;
&lt;p&gt;n=1&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,\tilde{y}} = \sqrt{\frac{nh^{2}}{1+(n-1)t}} \\
= \sqrt{\frac{1*0.3}{1+(1-1)*0.5}} \\
= 0.55
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结果等同于单次记录结果。&lt;/p&gt;
&lt;p&gt;n=2&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,\tilde{y}} = \sqrt{\frac{nh^{2}}{1+(n-1)t}} \\
= \sqrt{\frac{2*0.3}{1+(2-1)*0.5}} \\
= 0.63
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;n=6&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,\tilde{y}} = \sqrt{\frac{nh^{2}}{1+(n-1)t}} \\
= \sqrt{\frac{6*0.3}{1+(6-1)*0.5}} \\
= 0.72
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;n=10&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
r_{a,\tilde{y}} = \sqrt{\frac{nh^{2}}{1+(n-1)t}} \\
= \sqrt{\frac{10*0.3}{1+(10-1)*0.5}} \\
= 0.74
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当重复力比较高时，多次跟单次测量的准确度并无太大差别。这个其实是很朴素的道理，当重复力低时，也就是表示受环境影响较大，需要多次测量才会更加准确，但是当重复力比较高时，测量一次和多次的结果是一致的。&lt;/p&gt;
&lt;p&gt;如果重复力不同，那么基于不同重复力的育种值预测准确度结果，是没有可比性的。譬如如果t=1，那么无论n是多少，其育种值预测准确度都是h。但是如果t小于1，那么预测准确会大于h，但是不同重复率之间，应该是不可以比较的。&lt;/p&gt;
&lt;p&gt;例子1.2&lt;/p&gt;
&lt;p&gt;母牛第一次和第二次哺乳期的平均产奶总体均值是6000kg。一头母牛第一次和第二次哺乳期的平均产奶量是8000kg。产奶量的表型方差和遗传力是600kg和0.3，两次哺乳期产奶量的相关系数是0.5（重复力），预测育种值及其准确度。&lt;/p&gt;
&lt;p&gt;根据公式1.12&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\hat{a}_{1} = b(\tilde{y}_{i}-\mu) \\
=b(8000-6000) \\
=2000b
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中b根据公式1.17计算&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
b = \frac{nh^{2}}{1+(n-1)t} \\
= \frac{2*0.3}{1+(2-1)*0.5} \\
= 0.4
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这头奶牛的育种值为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\hat{a}_{1} = b(\tilde{y}_{i}-\mu) \\
=0.4*(8000-6000) \\
=2000*0.4 \\
=800 kg
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;育种值估计的准确度为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[r_{a,\tilde{y}} = \sqrt{b} = \sqrt{0.4} = 0.632\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table学习笔记4</title>
      <link>/post/data-table-note-4/</link>
      <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-table-note-4/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;data.table的特点：&lt;strong&gt;减小计算复杂度&lt;/strong&gt;，降低&lt;strong&gt;计算时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;secondary-index&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.二级索引（Secondary index）&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1 什么是二级索引&lt;/h2&gt;
&lt;p&gt;二级索引与主键的区别：&lt;br /&gt;
* 不在内存中将整个data.table数据集重新排序。它只会计算某列的顺序，将这个顺序向量保存在一个附件的属性index里面。 * 一个data.table可以有多个二级索引。 见下面代码实例。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setindex(flights,origin)
head(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   1      914        14     1238        13         0      AA
## 2: 2014     1   1     1157        -3     1523        13         0      AA
## 3: 2014     1   1     1902         2     2224         9         0      AA
## 4: 2014     1   1      722        -8     1014       -26         0      AA
## 5: 2014     1   1     1347         2     1706         1         0      AA
## 6: 2014     1   1     1824         4     2145         0         0      AA
##    tailnum flight origin dest air_time distance hour min
## 1:  N338AA      1    JFK  LAX      359     2475    9  14
## 2:  N335AA      3    JFK  LAX      363     2475   11  57
## 3:  N327AA     21    JFK  LAX      351     2475   19   2
## 4:  N3EHAA     29    LGA  PBI      157     1035    7  22
## 5:  N319AA    117    JFK  LAX      350     2475   13  47
## 6:  N3DEAA    119    EWR  LAX      339     2454   18  24&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;index&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2 查看增加的index属性&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(attributes(flights))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;            
## [4] &amp;quot;.internal.selfref&amp;quot; &amp;quot;index&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data.table&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.3 查看data.table的二级索引&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;indices(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;origin&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.4 删除二级索引&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setindex(flights,NULL)
indices(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新创建一个索引&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setindex(flights,origin,dest)
indices(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;origin__dest&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setindex(flights,origin)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.5 什么情况下使用二级索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果循环使用一个主键，那么重排序是可以的；&lt;/li&gt;
&lt;li&gt;如果经常更换主键，那么重排序会耗费大量的时间，使用二级索引非常有用的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;on&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. 使用参数on更为方便的进行二级索引和提取子集&lt;/h1&gt;
&lt;div id=&#34;i&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.1 利用参数i提取子集&lt;/h2&gt;
&lt;p&gt;提取origin是JFK的所有航班记录：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;),on=&amp;quot;origin&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        year month day dep_time dep_delay arr_time arr_delay cancelled
##     1: 2014     1   1      914        14     1238        13         0
##     2: 2014     1   1     1157        -3     1523        13         0
##     3: 2014     1   1     1902         2     2224         9         0
##     4: 2014     1   1     1347         2     1706         1         0
##     5: 2014     1   1     2133        -2       37       -18         0
##    ---                                                               
## 81479: 2014    10  31     1705        -4     2024       -21         0
## 81480: 2014    10  31     1827        -2     2133       -37         0
## 81481: 2014    10  31     1753         0     2039       -33         0
## 81482: 2014    10  31      924        -6     1228       -38         0
## 81483: 2014    10  31     1124        -6     1408       -38         0
##        carrier tailnum flight origin dest air_time distance hour min
##     1:      AA  N338AA      1    JFK  LAX      359     2475    9  14
##     2:      AA  N335AA      3    JFK  LAX      363     2475   11  57
##     3:      AA  N327AA     21    JFK  LAX      351     2475   19   2
##     4:      AA  N319AA    117    JFK  LAX      350     2475   13  47
##     5:      AA  N323AA    185    JFK  LAX      338     2475   21  33
##    ---                                                              
## 81479:      UA  N596UA    512    JFK  SFO      337     2586   17   5
## 81480:      UA  N568UA    514    JFK  SFO      344     2586   18  27
## 81481:      UA  N518UA    535    JFK  LAX      320     2475   17  53
## 81482:      UA  N512UA    541    JFK  SFO      343     2586    9  24
## 81483:      UA  N590UA    703    JFK  LAX      323     2475   11  24&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这段语句执行的subset是通过创建二级索引，基于快速二分法搜索的。但记住，它不会把这个二级索引自动创建为data.table的一个属性。&lt;/li&gt;
&lt;li&gt;如果已经添加了一个二级索引了，那么参数on就可以直接使用这个二级索引，而不是再对整个航班信息flights进行计算。&lt;/li&gt;
&lt;li&gt;on必须是一个字符型的向量&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2 进一步选择列&lt;/h2&gt;
&lt;p&gt;筛选满足条件origin=“LGA” 和dest=“TPA”的数据集，并且只返回arr_delay列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(arr_delay),on=c(&amp;quot;origin&amp;quot;,&amp;quot;dest&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       arr_delay
##    1:         1
##    2:        14
##    3:       -17
##    4:        -4
##    5:       -12
##   ---          
## 1848:        39
## 1849:       -24
## 1850:       -12
## 1851:        21
## 1852:       -11&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.3 进一步对结果按照降序排列&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(arr_delay),on=c(&amp;quot;origin&amp;quot;,&amp;quot;dest&amp;quot;)][order(-arr_delay)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       arr_delay
##    1:       486
##    2:       380
##    3:       351
##    4:       318
##    5:       300
##   ---          
## 1848:       -40
## 1849:       -43
## 1850:       -46
## 1851:       -48
## 1852:       -49&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;j&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.4 参数j计算&lt;/h2&gt;
&lt;p&gt;找出满足条件origin=“LGA” 和dest=“TPA”的航班记录中，最长到达延误时间。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(MaxArrDelay=max(arr_delay),MinArrDelay=min(arr_delay)),on=c(&amp;quot;origin&amp;quot;,&amp;quot;dest&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    MaxArrDelay MinArrDelay
## 1:         486         -49&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;by&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.5 参数by聚合&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;),max(dep_delay),keyby=month,on=&amp;quot;origin&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     month   V1
##  1:     1  881
##  2:     1 1014
##  3:     1  920
##  4:     1 1241
##  5:     1  853
##  6:     1  798
##  7:     1  926
##  8:     1  772
##  9:     1  553
## 10:     1  848&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;jsub-assign&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.6 参数j里使用操作符“:=”进行sub-assign&lt;/h2&gt;
&lt;p&gt;是继续使用以前的例子，hour中的24替换为0。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[,sort(unique(hour))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
## [24] 23 24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(24L),hour:=0L,on=&amp;quot;hour&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;这是二级索引的一大优点。以前章节，只是为了更新一些行的hour列的取值，我们不得不调用函数setkey()将hour列设置为主键，这必须对整个data.table进行重新排序。但是现在，用参数on，原数据的顺序并没有改变，操作反而更快了！而代码还是如此简洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;3.自动索引&lt;/h1&gt;
&lt;p&gt;data.table 会默认对&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;%in%&lt;/code&gt;操作符自动创建索引，并且作为data.table的属性保存起来。&lt;/p&gt;
&lt;p&gt;首先创建1个非常大的data.table来测试性能。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1L)
dt = data.table(x=sample(1e5L,1e7L,TRUE),y=runif(100L))
print(object.size(dt),units = &amp;quot;Mb&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 114.4 Mb&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;列出dt的属性。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(attributes(dt))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;            
## [4] &amp;quot;.internal.selfref&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次使用&lt;code&gt;==&lt;/code&gt;或&lt;code&gt;%in%&lt;/code&gt;时，会自动创建一个二级索引，用来进行subset。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(t1 &amp;lt;- system.time(ans &amp;lt;- dt[x==989L]))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 用户 系统 流逝 
## 0.17 0.01 0.19&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(attributes(dt))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;names&amp;quot;             &amp;quot;row.names&amp;quot;         &amp;quot;class&amp;quot;            
## [4] &amp;quot;.internal.selfref&amp;quot; &amp;quot;index&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新进行一次subset，由于索引已经创建，速度会很快。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(t2 &amp;lt;- system.time(ans &amp;lt;- dt[x==989L]))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 用户 系统 流逝 
##    0    0    0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从两次对比时间，可以看出，第二次时间已经大为缩短。到写这篇博客为止，还没有对&amp;gt;=，&amp;lt;=等符号自动二级索引。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;indices(dt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setindex(dt,NULL)
(t3 &amp;lt;- system.time(ans &amp;lt;- dt[x&amp;gt;=989L]))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 用户 系统 流逝 
## 0.20 0.00 0.21&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;indices(dt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table学习笔记3</title>
      <link>/post/data-table-note-3/</link>
      <pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-table-note-3/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;data.table的特点：&lt;strong&gt;减小计算复杂度&lt;/strong&gt;，降低&lt;strong&gt;计算时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.主键&lt;/h1&gt;
&lt;p&gt;利用主键进行subset，速度会更加快。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;设置主键&lt;/h2&gt;
&lt;p&gt;通过函数&lt;code&gt;setkey()&lt;/code&gt;来设置主键。下边代码将origin列设置为主键。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setkey(flights,origin)
setkey(flights,&amp;quot;origin&amp;quot;)
head(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   1     1824         4     2145         0         0      AA
## 2: 2014     1   1     1655        -5     2003       -17         0      AA
## 3: 2014     1   1     1611       191     1910       185         0      AA
## 4: 2014     1   1     1449        -1     1753        -2         0      AA
## 5: 2014     1   1      607        -3      905       -10         0      AA
## 6: 2014     1   1      949         4     1243       -17         0      AA
##    tailnum flight origin dest air_time distance hour min
## 1:  N3DEAA    119    EWR  LAX      339     2454   18  24
## 2:  N5CFAA    172    EWR  MIA      161     1085   16  55
## 3:  N471AA    300    EWR  DFW      214     1372   16  11
## 4:  N4WNAA    320    EWR  DFW      214     1372   14  49
## 5:  N5DMAA   1205    EWR  MIA      154     1085    6   7
## 6:  N491AA   1223    EWR  DFW      215     1372    9  49&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;origin列设置为主键后，一个明显特征，其中的元素从小到大排序了。主键列中元素并不唯一，可以重复。 列被setkey后，速度提升很快。利用microbenchmark包进行测试。设置为主键后，的确快一些。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(microbenchmark)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 载入需要的程辑包：microbenchmark&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark(flights[.(&amp;quot;JFK&amp;quot;)],flights.copy[origin == &amp;quot;JFK&amp;quot;])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: milliseconds
##                           expr      min       lq      mean   median
##              flights[.(&amp;quot;JFK&amp;quot;)] 5.871177 7.055479  9.300985 8.173827
##  flights.copy[origin == &amp;quot;JFK&amp;quot;] 7.350690 8.589226 12.197023 9.923161
##        uq      max neval cld
##  11.53849 19.96891   100  a 
##  12.89601 66.70877   100   b&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;因为已经将主键设置为 origin列了，所以只要直接指定“JFK”就可以了。这里 .()用来在data.table的主键（也就是flights 的 origin列）里，查找“JFK”。&lt;/li&gt;
&lt;li&gt;首先，满足“JFK”条件的行的索引都被获取到。然后，这些行的哪些信息是必要的呢。既然参数j里没有指定任何表达式，这些行的所有列都被返回了。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果主键是字符型的列，那么可以省略 .()，就像用行名subset一个data.frame的行的时候。 flights[“JFK”] ## same as flights[.(“JFK”)]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们可以根据需要指定多个值 flights[c(“JFK”, “LGA”)] ## same as flights[.(c(“JFK”, “LGA”))] 这返回所有 origin列是“JFK” 或者 “LGA”的所有行。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[c(&amp;quot;JFK&amp;quot;, &amp;quot;LGA&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         year month day dep_time dep_delay arr_time arr_delay cancelled
##      1: 2014     1   1      914        14     1238        13         0
##      2: 2014     1   1     1157        -3     1523        13         0
##      3: 2014     1   1     1902         2     2224         9         0
##      4: 2014     1   1     1347         2     1706         1         0
##      5: 2014     1   1     2133        -2       37       -18         0
##     ---                                                               
## 165912: 2014    10  31      609        24      843        -5         0
## 165913: 2014    10  31     1459         1     1747       -30         0
## 165914: 2014    10  31     1102        -8     1311        16         0
## 165915: 2014    10  31     1106        -4     1325        15         0
## 165916: 2014    10  31      824        -5     1045         1         0
##         carrier tailnum flight origin dest air_time distance hour min
##      1:      AA  N338AA      1    JFK  LAX      359     2475    9  14
##      2:      AA  N335AA      3    JFK  LAX      363     2475   11  57
##      3:      AA  N327AA     21    JFK  LAX      351     2475   19   2
##      4:      AA  N319AA    117    JFK  LAX      350     2475   13  47
##      5:      AA  N323AA    185    JFK  LAX      338     2475   21  33
##     ---                                                              
## 165912:      UA  N16709   1714    LGA  IAH      198     1416    6   9
## 165913:      UA  N23708   1744    LGA  IAH      201     1416   14  59
## 165914:      MQ  N827MQ   3591    LGA  RDU       83      431   11   2
## 165915:      MQ  N511MQ   3592    LGA  DTW       75      502   11   6
## 165916:      MQ  N813MQ   3599    LGA  SDF      110      659    8  24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(c(&amp;quot;JFK&amp;quot;, &amp;quot;LGA&amp;quot;))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         year month day dep_time dep_delay arr_time arr_delay cancelled
##      1: 2014     1   1      914        14     1238        13         0
##      2: 2014     1   1     1157        -3     1523        13         0
##      3: 2014     1   1     1902         2     2224         9         0
##      4: 2014     1   1     1347         2     1706         1         0
##      5: 2014     1   1     2133        -2       37       -18         0
##     ---                                                               
## 165912: 2014    10  31      609        24      843        -5         0
## 165913: 2014    10  31     1459         1     1747       -30         0
## 165914: 2014    10  31     1102        -8     1311        16         0
## 165915: 2014    10  31     1106        -4     1325        15         0
## 165916: 2014    10  31      824        -5     1045         1         0
##         carrier tailnum flight origin dest air_time distance hour min
##      1:      AA  N338AA      1    JFK  LAX      359     2475    9  14
##      2:      AA  N335AA      3    JFK  LAX      363     2475   11  57
##      3:      AA  N327AA     21    JFK  LAX      351     2475   19   2
##      4:      AA  N319AA    117    JFK  LAX      350     2475   13  47
##      5:      AA  N323AA    185    JFK  LAX      338     2475   21  33
##     ---                                                              
## 165912:      UA  N16709   1714    LGA  IAH      198     1416    6   9
## 165913:      UA  N23708   1744    LGA  IAH      201     1416   14  59
## 165914:      MQ  N827MQ   3591    LGA  RDU       83      431   11   2
## 165915:      MQ  N511MQ   3592    LGA  DTW       75      502   11   6
## 165916:      MQ  N813MQ   3599    LGA  SDF      110      659    8  24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用函数 &lt;code&gt;key()&lt;/code&gt;，获得被设置为主键的列名。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;key(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;origin&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;key(flights.copy)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;函数 key() 返回主键列名的字符型向量。&lt;/li&gt;
&lt;li&gt;如果data.table没有设置过主键，返回 NULL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. 更多主键&lt;/h1&gt;
&lt;p&gt;可以把主键理解为功能更强大的行名。可以设置多列为主键。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setkey(flights,origin,dest)
head( flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   2      724        -2      810       -25         0      EV
## 2: 2014     1   3     2313        88        9        79         0      EV
## 3: 2014     1   4     1526       220     1618       211         0      EV
## 4: 2014     1   4      755        35      848        19         0      EV
## 5: 2014     1   5      817        47      921        42         0      EV
## 6: 2014     1   5     2301        66        2        62         0      EV
##    tailnum flight origin dest air_time distance hour min
## 1:  N11547   4373    EWR  ALB       30      143    7  24
## 2:  N18120   4470    EWR  ALB       29      143   23  13
## 3:  N11184   4373    EWR  ALB       32      143   15  26
## 4:  N14905   4551    EWR  ALB       32      143    7  55
## 5:  N19966   4470    EWR  ALB       26      143    8  17
## 6:  N19966   4682    EWR  ALB       31      143   23   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从返回结果看，origin和dest这两列被重新排序了。&lt;/p&gt;
&lt;p&gt;提取满足orgin==“JFK”，dest== “MIA”条件的数据集。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;,&amp;quot;MIA&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       year month day dep_time dep_delay arr_time arr_delay cancelled
##    1: 2014     1   1     1509        -1     1828       -17         0
##    2: 2014     1   1      917         7     1227        -8         0
##    3: 2014     1   1     1227         2     1534        -1         0
##    4: 2014     1   1      546         6      853         3         0
##    5: 2014     1   1     1736         6     2043       -12         0
##   ---                                                               
## 2746: 2014    10  31     1659        -1     1956       -22         0
## 2747: 2014    10  31      826        -3     1116       -20         0
## 2748: 2014    10  31      647         2      941       -17         0
## 2749: 2014    10  31      542        -3      834       -12         0
## 2750: 2014    10  31     1944        29     2232         4         0
##       carrier tailnum flight origin dest air_time distance hour min
##    1:      AA  N5FJAA    145    JFK  MIA      161     1089   15   9
##    2:      AA  N5DWAA   1085    JFK  MIA      166     1089    9  17
##    3:      AA  N635AA   1697    JFK  MIA      164     1089   12  27
##    4:      AA  N5CGAA   2243    JFK  MIA      157     1089    5  46
##    5:      AA  N397AA   2351    JFK  MIA      154     1089   17  36
##   ---                                                              
## 2746:      AA  N5FNAA   2351    JFK  MIA      148     1089   16  59
## 2747:      AA  N5EYAA   1085    JFK  MIA      146     1089    8  26
## 2748:      AA  N5BTAA   1101    JFK  MIA      150     1089    6  47
## 2749:      AA  N3ETAA   2299    JFK  MIA      150     1089    5  42
## 2750:      AA  N5FSAA   2387    JFK  MIA      146     1089   19  44&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当有两个主键时，对第一个主键，这样写是ok的。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        year month day dep_time dep_delay arr_time arr_delay cancelled
##     1: 2014     1   1     2011        10     2308         4         0
##     2: 2014     1   2     2215       134      145       161         0
##     3: 2014     1   7     2006         6     2314         6         0
##     4: 2014     1   8     2009        15     2252       -15         0
##     5: 2014     1   9     2039        45     2339        32         0
##    ---                                                               
## 81479: 2014    10  31      800         0     1040       -18         0
## 81480: 2014    10  31     1932         1     2228        -8         0
## 81481: 2014    10  31     1443        -2     1726       -22         0
## 81482: 2014    10  31      957        -8     1255        -5         0
## 81483: 2014    10  31      831        -4     1118       -18         0
##        carrier tailnum flight origin dest air_time distance hour min
##     1:      B6  N766JB     65    JFK  ABQ      280     1826   20  11
##     2:      B6  N507JB     65    JFK  ABQ      252     1826   22  15
##     3:      B6  N652JB     65    JFK  ABQ      269     1826   20   6
##     4:      B6  N613JB     65    JFK  ABQ      259     1826   20   9
##     5:      B6  N598JB     65    JFK  ABQ      267     1826   20  39
##    ---                                                              
## 81479:      DL  N915AT   2165    JFK  TPA      142     1005    8   0
## 81480:      B6  N516JB    225    JFK  TPA      149     1005   19  32
## 81481:      B6  N334JB    325    JFK  TPA      145     1005   14  43
## 81482:      B6  N637JB    925    JFK  TPA      149     1005    9  57
## 81483:      B6  N595JB   1025    JFK  TPA      145     1005    8  31&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何只对第二个主键进行过滤?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;MIA&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1:   NA    NA  NA       NA        NA       NA        NA        NA      NA
##    tailnum flight origin dest air_time distance hour min
## 1:      NA     NA    MIA   NA       NA       NA   NA  NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;像上边这样是行不通的。必须要给出第一个主键的所有值,通过&lt;code&gt;unique(origin)&lt;/code&gt;来实现。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(unique(origin),&amp;quot;MIA&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       year month day dep_time dep_delay arr_time arr_delay cancelled
##    1: 2014     1   1     1655        -5     2003       -17         0
##    2: 2014     1   1      607        -3      905       -10         0
##    3: 2014     1   1     1125        -5     1427        -8         0
##    4: 2014     1   1     1533        43     1840        42         0
##    5: 2014     1   1     2130        60       29        49         0
##   ---                                                               
## 9924: 2014    10  31     1348       -11     1658        -8         0
## 9925: 2014    10  31      950        -5     1257       -11         0
## 9926: 2014    10  31      658        -2     1017        10         0
## 9927: 2014    10  31     1913        -2     2212       -16         0
## 9928: 2014    10  31     1530         1     1839       -11         0
##       carrier tailnum flight origin dest air_time distance hour min
##    1:      AA  N5CFAA    172    EWR  MIA      161     1085   16  55
##    2:      AA  N5DMAA   1205    EWR  MIA      154     1085    6   7
##    3:      AA  N3AGAA   1623    EWR  MIA      157     1085   11  25
##    4:      UA  N491UA    244    EWR  MIA      155     1085   15  33
##    5:      UA  N476UA    308    EWR  MIA      162     1085   21  30
##   ---                                                              
## 9924:      AA  N3AMAA   2283    LGA  MIA      157     1096   13  48
## 9925:      AA  N3LFAA   2287    LGA  MIA      150     1096    9  50
## 9926:      AA  N3HNAA   2451    LGA  MIA      156     1096    6  58
## 9927:      AA  N3LFAA   2455    LGA  MIA      156     1096   19  13
## 9928:      US  N768US   1715    LGA  MIA      164     1096   15  30&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;j-by&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;3. 和参数j, by一起使用&lt;/h1&gt;
&lt;p&gt;提取满足origin=“LGA”和dest=“TPA”这两个条件的数据集，并且只返回arr_delay列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;key(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;origin&amp;quot; &amp;quot;dest&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(arr_delay)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       arr_delay
##    1:         1
##    2:        14
##    3:       -17
##    4:        -4
##    5:       -12
##   ---          
## 1848:        39
## 1849:       -24
## 1850:       -12
## 1851:        21
## 1852:       -11&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;chaining&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;chaining表达式，链式表达式。&lt;/h2&gt;
&lt;p&gt;对上边的表达式生成的数据集，进一步对arr_delay按照降序排列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(arr_delay)][order(-arr_delay)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       arr_delay
##    1:       486
##    2:       380
##    3:       351
##    4:       318
##    5:       300
##   ---          
## 1848:       -40
## 1849:       -43
## 1850:       -46
## 1851:       -48
## 1852:       -49&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;j&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;j参数运算&lt;/h2&gt;
&lt;p&gt;找出从LGA到TPA的到达航班最长延迟时间。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;LGA&amp;quot;,&amp;quot;TPA&amp;quot;),.(max(arr_delay))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     V1
## 1: 486&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以跟降序排列的第一行结果对比验证。两者应该是一致的。&lt;/p&gt;
&lt;p&gt;利用主键，把hour列中的24替换为0。注意，替换后，由于主键列的内容发生变化，hour的主键特性消失。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setkey(flights,hour)
key(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;hour&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(24),hour:=0L]
flights[,unique(hour)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
## [24] 23&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;key(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;by&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;用参数by进行聚合&lt;/h2&gt;
&lt;p&gt;每个月从“JFK”起飞航班的最大起飞延误时间，按照月排序。注意用到了&lt;code&gt;keyby&lt;/code&gt;参数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setkey(flights,origin,dest)
flights[.(&amp;quot;JFK&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        year month day dep_time dep_delay arr_time arr_delay cancelled
##     1: 2014     7   2       40       280      336       282         0
##     2: 2014     1  13     1957         3     2254       -13         0
##     3: 2014     1  14     1955        -5     2226       -42         0
##     4: 2014     1  16     1953        -1     2232       -35         0
##     5: 2014     1  17     1946        -8     2208       -59         0
##    ---                                                               
## 81479: 2014     8   9     2201        31       55        34         0
## 81480: 2014     8  10     2211        41       40        19         0
## 81481: 2014     8  21     2243        73      152        91         0
## 81482: 2014     4  15     2347       257      245       250         0
## 81483: 2014     8  16     2323       113      159        98         0
##        carrier tailnum flight origin dest air_time distance hour min
##     1:      B6  N520JB     65    JFK  ABQ      244     1826    0  40
##     2:      B6  N583JB     65    JFK  ABQ      262     1826   19  57
##     3:      B6  N641JB     65    JFK  ABQ      254     1826   19  55
##     4:      B6  N828JB     65    JFK  ABQ      248     1826   19  53
##     5:      B6  N531JB     65    JFK  ABQ      240     1826   19  46
##    ---                                                              
## 81479:      B6  N591JB    725    JFK  TPA      128     1005   22   1
## 81480:      B6  N585JB    725    JFK  TPA      128     1005   22  11
## 81481:      B6  N564JB    725    JFK  TPA      133     1005   22  43
## 81482:      B6  N588JB    225    JFK  TPA      156     1005   23  47
## 81483:      B6  N590JB    725    JFK  TPA      131     1005   23  23&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.max.dep_delay.per.month &amp;lt;- flights[.(&amp;quot;JFK&amp;quot;),max(dep_delay),keyby=month]
head(flights.max.dep_delay.per.month)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    month   V1
## 1:     1  881
## 2:     2 1014
## 3:     3  920
## 4:     4 1241
## 5:     5  853
## 6:     6  798&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;multnomatch&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;4. 两个重要的参数mult和nomatch&lt;/h1&gt;
&lt;div id=&#34;mult&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;mult&lt;/code&gt;参数&lt;/h2&gt;
&lt;p&gt;用来设置返回的行数, &lt;code&gt;first&lt;/code&gt;只返回第一行,&lt;code&gt;last&lt;/code&gt;返回最后一行，&lt;code&gt;all&lt;/code&gt;返回所有行。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;,&amp;quot;MIA&amp;quot;),mult=&amp;quot;first&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   1      546         6      853         3         0      AA
##    tailnum flight origin dest air_time distance hour min
## 1:  N5CGAA   2243    JFK  MIA      157     1089    5  46&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;,&amp;quot;MIA&amp;quot;),mult=&amp;quot;last&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     2   3     2301       331      210       315         0      AA
##    tailnum flight origin dest air_time distance hour min
## 1:  N360AA   2351    JFK  MIA      146     1089   23   1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(&amp;quot;JFK&amp;quot;,&amp;quot;MIA&amp;quot;),mult=&amp;quot;all&amp;quot;]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       year month day dep_time dep_delay arr_time arr_delay cancelled
##    1: 2014     1   1      546         6      853         3         0
##    2: 2014     1   2      544         4      915        25         0
##    3: 2014     1   4      554        14      902        12         0
##    4: 2014     1   9      538        -2      837       -13         0
##    5: 2014     1  10      539        -1      842        -8         0
##   ---                                                               
## 2746: 2014    10   4     2137       142       33       125         0
## 2747: 2014    10  16     2145       150       38       130         0
## 2748: 2014     8  10     2231       302      126       277         0
## 2749: 2014     8  30     2231       196      112       164         0
## 2750: 2014     2   3     2301       331      210       315         0
##       carrier tailnum flight origin dest air_time distance hour min
##    1:      AA  N5CGAA   2243    JFK  MIA      157     1089    5  46
##    2:      AA  N5DTAA   2243    JFK  MIA      167     1089    5  44
##    3:      AA  N5ENAA   2243    JFK  MIA      162     1089    5  54
##    4:      AA  N640AA   2243    JFK  MIA      161     1089    5  38
##    5:      AA  N5CKAA   2243    JFK  MIA      158     1089    5  39
##   ---                                                              
## 2746:      AA  N5EWAA   2387    JFK  MIA      151     1089   21  37
## 2747:      AA  N5EKAA   2387    JFK  MIA      142     1089   21  45
## 2748:      AA  N5FSAA   2351    JFK  MIA      138     1089   22  31
## 2749:      AA  N5BSAA   2387    JFK  MIA      133     1089   22  31
## 2750:      AA  N360AA   2351    JFK  MIA      146     1089   23   1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;nomatch&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;nomatch&lt;/code&gt;参数&lt;/h2&gt;
&lt;p&gt;指定在没有找到符合条件的数据的情况下，是返回NA呢，还是跳过（不返回）。默认是返回NA，如果想跳过，设置&lt;code&gt;nomatch=0L&lt;/code&gt;。JFK+XNA不匹配数据库中的任何一条记录，因此在第一种方式中跳过，在第二种方式中用NA补充。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult=&amp;quot;last&amp;quot;, nomatch = 0L]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     5  23     1803       163     2003       148         0      MQ
## 2: 2014     2   3     1208       231     1516       268         0      EV
##    tailnum flight origin dest air_time distance hour min
## 1:  N515MQ   3553    LGA  XNA      158     1147   18   3
## 2:  N14148   4419    EWR  XNA      184     1131   12   8&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[.(c(&amp;quot;LGA&amp;quot;, &amp;quot;JFK&amp;quot;, &amp;quot;EWR&amp;quot;), &amp;quot;XNA&amp;quot;), mult=&amp;quot;last&amp;quot;, nomatch = NA]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     5  23     1803       163     2003       148         0      MQ
## 2:   NA    NA  NA       NA        NA       NA        NA        NA      NA
## 3: 2014     2   3     1208       231     1516       268         0      EV
##    tailnum flight origin dest air_time distance hour min
## 1:  N515MQ   3553    LGA  XNA      158     1147   18   3
## 2:      NA     NA    JFK  XNA       NA       NA   NA  NA
## 3:  N14148   4419    EWR  XNA      184     1131   12   8&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;vs&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;5. 二分法搜索vs向量搜索&lt;/h1&gt;
&lt;p&gt;探讨一下为什么设置主键后，速度会提升。&lt;br /&gt;
创建一个2000万行三列的数据。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1234)
N &amp;lt;- 2e7L
DT &amp;lt;-  data.table(x=sample(letters,N,TRUE),
                  y=sample(1000L,N,TRUE),
                  val=runif(N),key=c(&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;))
print(object.size(DT),units=&amp;quot;Mb&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 381.5 Mb&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;key(DT)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;x&amp;quot; &amp;quot;y&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(DT)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    x y       val
## 1: a 1 0.8506738
## 2: a 1 0.4633684
## 3: a 1 0.8655359
## 4: a 1 0.6826856
## 5: a 1 0.6953267
## 6: a 1 0.6032007&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上边代码产生了一个380M的数据集，用来测试和比较设置主键后的性能优化效果。&lt;/p&gt;
&lt;p&gt;现在要提取x=a 和 y=100的行。来比较直接向量提取和利用主键来做的性能差异。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(microbenchmark)
microbenchmark(DT[x==&amp;quot;a&amp;quot; &amp;amp; y==100L],DT[.(&amp;quot;a&amp;quot;,100L)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: microseconds
##                      expr        min         lq        mean     median
##  DT[x == &amp;quot;a&amp;quot; &amp;amp; y == 100L] 144995.843 182905.500 201683.7183 195724.888
##          DT[.(&amp;quot;a&amp;quot;, 100L)]    433.879    528.226    725.0278    663.888
##          uq        max neval cld
##  216434.459 363275.336   100   b
##     824.339   1834.969   100  a&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来，快了大约200多倍。的确是非常快。 看看给出的解释：中文地址在&lt;a href=&#34;https://youngspring1.github.io/post/2016/2016-03-22-datatable3/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;向量扫描&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在所有两千条数据中，逐行搜索 x列里值为“g”的行。这会生成一个有两千行的逻辑向量，根据和x列的批评结果，它每个元素的取值可能是TRUE, FALSE 以及 NA。&lt;/li&gt;
&lt;li&gt;相似的，在所有两千条数据中，逐行搜索 y列里值为“877”的行，再保存在另一个逻辑向量里面。&lt;/li&gt;
&lt;li&gt;操作符“&amp;amp;”对上面两个逻辑向量进行“且”运算，返回结果为TRUE的行 这就是所谓的“向量扫描”。效率非常低，特别是数据量很大、需要重复subset的时候。因为它每次不得不对整个数据全盘扫描。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;二分法搜索&lt;/h2&gt;
&lt;p&gt;这里有一个简单的示例。看看下面这组排过序的数字： 1, 5, 10, 19, 22, 23, 30 假设我们希望找到数字1的位置，用二分法搜索（因为这组数字是排过序的），我们是这么做的： * 从中间的数开始，它是19，不是1，而且 1&amp;lt;19。 * 既然我们要找的数字1小于19，那它应该排在19前面。所以我们可以无视19后面的那一半数据，因为它们都大于19. * 现在我们的数据只剩下1, 5, 10。再找到中间的数5，它不是1，而且 1&amp;lt;5。 * 现在我们的数据只剩下1。符合条件。这就是我们要找的数。 相反的，向量扫描需要扫描所有的数字，在这个例子中是7。&lt;/p&gt;
&lt;p&gt;用主键也就是二分法搜索的时间开销是&lt;strong&gt;O(logn)&lt;/strong&gt;，而用向量扫描，时间开销是&lt;strong&gt;O(n)&lt;/strong&gt;。当n（数据行数）非常大时，性能会差别很大。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table学习笔记2</title>
      <link>/post/data-table-note-2/</link>
      <pubDate>Fri, 07 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-table-note-2/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;data.table的特点：&lt;strong&gt;减小计算复杂度&lt;/strong&gt;，降低&lt;strong&gt;计算时间&lt;/strong&gt;。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;这一部分笔记主要讲述如何更新数据集，而不产生新的数据拷贝。&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;主要用到的符号是“:=”，类似于指针功能，通过引用更新列。&lt;/li&gt;
&lt;li&gt;本章的操作，实际上是把data.table作为一个数据库在操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.语义引用&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt;两种用法:&lt;/p&gt;
&lt;p&gt;左右相等方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DT[, c(&amp;quot;colA&amp;quot;, &amp;quot;colB&amp;quot;, ...) := list(valA, valB, ...)]

# when you have only one column to assign to you 
# can drop the quotes and list(), for convenience
DT[, colA := valA]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DT[, `:=`(colA = valA, # valA is assigned to colA
      colB = valB, # valB is assigned to colB
      ...
)]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;左右相等方式比较容易编码，特别是，事先不知道需要被赋值的列的时候。&lt;/li&gt;
&lt;li&gt;相对而言，函数方式更加趁手，可以少写代码。&lt;/li&gt;
&lt;li&gt;操作符“:=”没有返回值。&lt;/li&gt;
&lt;li&gt;既然参数j里面可以使用操作符“:=”，那么，就像上一讲中学习到的内容，我们可以和参数i和参数by一起，做些聚合的运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. 添加／更新／删除列&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.1 添加列&lt;/h2&gt;
&lt;p&gt;增加两列，计算航班的速度和延迟时间。注意，“:==”不返回任何值，为了方便查看，加入&lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[,&amp;quot;:=&amp;quot;(speed = distance / (air_time / 60),delay = arr_delay+dep_delay)][]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         year month day dep_time dep_delay arr_time arr_delay cancelled
##      1: 2014     1   1      914        14     1238        13         0
##      2: 2014     1   1     1157        -3     1523        13         0
##      3: 2014     1   1     1902         2     2224         9         0
##      4: 2014     1   1      722        -8     1014       -26         0
##      5: 2014     1   1     1347         2     1706         1         0
##     ---                                                               
## 253312: 2014    10  31     1459         1     1747       -30         0
## 253313: 2014    10  31      854        -5     1147       -14         0
## 253314: 2014    10  31     1102        -8     1311        16         0
## 253315: 2014    10  31     1106        -4     1325        15         0
## 253316: 2014    10  31      824        -5     1045         1         0
##         carrier tailnum flight origin dest air_time distance hour min
##      1:      AA  N338AA      1    JFK  LAX      359     2475    9  14
##      2:      AA  N335AA      3    JFK  LAX      363     2475   11  57
##      3:      AA  N327AA     21    JFK  LAX      351     2475   19   2
##      4:      AA  N3EHAA     29    LGA  PBI      157     1035    7  22
##      5:      AA  N319AA    117    JFK  LAX      350     2475   13  47
##     ---                                                              
## 253312:      UA  N23708   1744    LGA  IAH      201     1416   14  59
## 253313:      UA  N33132   1758    EWR  IAH      189     1400    8  54
## 253314:      MQ  N827MQ   3591    LGA  RDU       83      431   11   2
## 253315:      MQ  N511MQ   3592    LGA  DTW       75      502   11   6
## 253316:      MQ  N813MQ   3599    LGA  SDF      110      659    8  24
##            speed delay
##      1: 413.6490    27
##      2: 409.0909    10
##      3: 423.0769    11
##      4: 395.5414   -34
##      5: 424.2857     3
##     ---               
## 253312: 422.6866   -29
## 253313: 444.4444   -19
## 253314: 311.5663     8
## 253315: 401.6000    11
## 253316: 359.4545    -4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2 更新列&lt;/h2&gt;
&lt;p&gt;观察 fligths 里的 hour列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[,sort(unique(hour))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
## [24] 23 24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;0和24同时存在，二者其实是等同的。因此，可以把24换为0。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[hour == 24L,hour := 0L]
flights[,sort(unique(hour))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22
## [24] 23&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.3删除列&lt;/h2&gt;
&lt;p&gt;譬如删除speed列&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[,speed := NULL,]
str(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Classes &amp;#39;data.table&amp;#39; and &amp;#39;data.frame&amp;#39;:   253316 obs. of  18 variables:
##  $ year     : int  2014 2014 2014 2014 2014 2014 2014 2014 2014 2014 ...
##  $ month    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ day      : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ dep_time : int  914 1157 1902 722 1347 1824 2133 1542 1509 1848 ...
##  $ dep_delay: int  14 -3 2 -8 2 4 -2 -3 -1 -2 ...
##  $ arr_time : int  1238 1523 2224 1014 1706 2145 37 1906 1828 2206 ...
##  $ arr_delay: int  13 13 9 -26 1 0 -18 -14 -17 -14 ...
##  $ cancelled: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ carrier  : chr  &amp;quot;AA&amp;quot; &amp;quot;AA&amp;quot; &amp;quot;AA&amp;quot; &amp;quot;AA&amp;quot; ...
##  $ tailnum  : chr  &amp;quot;N338AA&amp;quot; &amp;quot;N335AA&amp;quot; &amp;quot;N327AA&amp;quot; &amp;quot;N3EHAA&amp;quot; ...
##  $ flight   : int  1 3 21 29 117 119 185 133 145 235 ...
##  $ origin   : chr  &amp;quot;JFK&amp;quot; &amp;quot;JFK&amp;quot; &amp;quot;JFK&amp;quot; &amp;quot;LGA&amp;quot; ...
##  $ dest     : chr  &amp;quot;LAX&amp;quot; &amp;quot;LAX&amp;quot; &amp;quot;LAX&amp;quot; &amp;quot;PBI&amp;quot; ...
##  $ air_time : int  359 363 351 157 350 339 338 356 161 349 ...
##  $ distance : int  2475 2475 2475 1035 2475 2454 2475 2475 1089 2422 ...
##  $ hour     : int  9 11 19 7 13 18 21 15 15 18 ...
##  $ min      : int  14 57 2 22 47 24 33 42 9 48 ...
##  $ delay    : int  27 10 11 -34 3 4 -20 -17 -18 -16 ...
##  - attr(*, &amp;quot;.internal.selfref&amp;quot;)=&amp;lt;externalptr&amp;gt; 
##  - attr(*, &amp;quot;index&amp;quot;)= int&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;3.在分组的情况下使用“:=”&lt;/h1&gt;
&lt;p&gt;感觉分组情况下，就地更新列，并不符合常规。这样对数据集的改动太大了。这里其实不是我理解的意思是，&lt;strong&gt;并不是用分组后的统计结果替代原数据集&lt;/strong&gt;。而是根据分组统计后的结果，更新列。 譬如，从origin到dest，延迟时间最长为多少？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[, max_delay_time := max(dep_delay+arr_delay), keyby=.(origin, dest)]
head(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   2      724        -2      810       -25         0      EV
## 2: 2014     1   3     2313        88        9        79         0      EV
## 3: 2014     1   4     1526       220     1618       211         0      EV
## 4: 2014     1   4      755        35      848        19         0      EV
## 5: 2014     1   5      817        47      921        42         0      EV
## 6: 2014     1   5     2301        66        2        62         0      EV
##    tailnum flight origin dest air_time distance hour min delay
## 1:  N11547   4373    EWR  ALB       30      143    7  24   -27
## 2:  N18120   4470    EWR  ALB       29      143   23  13   167
## 3:  N11184   4373    EWR  ALB       32      143   15  26   431
## 4:  N14905   4551    EWR  ALB       32      143    7  55    54
## 5:  N19966   4470    EWR  ALB       26      143    8  17    89
## 6:  N19966   4682    EWR  ALB       31      143   23   1   128
##    max_delay_time
## 1:            618
## 2:            618
## 3:            618
## 4:            618
## 5:            618
## 6:            618&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果可以看到，新增加了一列&lt;code&gt;max_delay_time&lt;/code&gt;，而且从EWR-ALB区间，该列值为618，为最大值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;4. 对多列数据进行操作&lt;/h1&gt;
&lt;p&gt;添加了两列：统计每个月，最长的出发延迟时间、到达延迟时间&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;in_cols  = c(&amp;quot;dep_delay&amp;quot;, &amp;quot;arr_delay&amp;quot;)
out_cols = c(&amp;quot;max_dep_delay&amp;quot;, &amp;quot;max_arr_delay&amp;quot;)
flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols]
head(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   2      724        -2      810       -25         0      EV
## 2: 2014     1   3     2313        88        9        79         0      EV
## 3: 2014     1   4     1526       220     1618       211         0      EV
## 4: 2014     1   4      755        35      848        19         0      EV
## 5: 2014     1   5      817        47      921        42         0      EV
## 6: 2014     1   5     2301        66        2        62         0      EV
##    tailnum flight origin dest air_time distance hour min delay
## 1:  N11547   4373    EWR  ALB       30      143    7  24   -27
## 2:  N18120   4470    EWR  ALB       29      143   23  13   167
## 3:  N11184   4373    EWR  ALB       32      143   15  26   431
## 4:  N14905   4551    EWR  ALB       32      143    7  55    54
## 5:  N19966   4470    EWR  ALB       26      143    8  17    89
## 6:  N19966   4682    EWR  ALB       31      143   23   1   128
##    max_delay_time max_dep_delay max_arr_delay
## 1:            618           973           996
## 2:            618           973           996
## 3:            618           973           996
## 4:            618           973           996
## 5:            618           973           996
## 6:            618           973           996&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一种形式&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights[,c(&amp;quot;max_dep_delay&amp;quot;, &amp;quot;max_arr_delay&amp;quot;) := lapply(.SD, max),.SDcols = c(&amp;quot;dep_delay&amp;quot;, &amp;quot;arr_delay&amp;quot;)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>data.table学习笔记1</title>
      <link>/post/data-table-note-1/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/data-table-note-1/</guid>
      <description>&lt;p&gt;data.table的特点：&lt;strong&gt;减小计算复杂度&lt;/strong&gt;，降低&lt;strong&gt;计算时间&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.数据&lt;/h1&gt;
&lt;p&gt;教程中，使用&lt;a href=&#34;https://raw.githubusercontent.com/wiki/arunsrinivasan/%20flights/NYCflights14/flights14.csv&#34;&gt;NYC-flights14数据集&lt;/a&gt;，纽约机场2014年出发的所有航班信息，时间是2014.01-10月份。下载到本地目录，与Rmd代码在同一目录 data.table中提供了fread()函数，用于快速读取大数据。&lt;br /&gt;
执行代码前，首先运行&lt;code&gt;setwd()&lt;/code&gt;或者通过rstudio软件&lt;code&gt;Session&lt;/code&gt; -&amp;gt; &lt;code&gt;Set Working Directory&lt;/code&gt; -&amp;gt; &lt;code&gt;To Source File Location&lt;/code&gt;，将工作目录切换到代码文件和数据文件所在路径。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;require(data.table)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 载入需要的程辑包：data.table&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights &amp;lt;- fread(&amp;quot;flights14.csv&amp;quot;)
flights&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         year month day dep_time dep_delay arr_time arr_delay cancelled
##      1: 2014     1   1      914        14     1238        13         0
##      2: 2014     1   1     1157        -3     1523        13         0
##      3: 2014     1   1     1902         2     2224         9         0
##      4: 2014     1   1      722        -8     1014       -26         0
##      5: 2014     1   1     1347         2     1706         1         0
##     ---                                                               
## 253312: 2014    10  31     1459         1     1747       -30         0
## 253313: 2014    10  31      854        -5     1147       -14         0
## 253314: 2014    10  31     1102        -8     1311        16         0
## 253315: 2014    10  31     1106        -4     1325        15         0
## 253316: 2014    10  31      824        -5     1045         1         0
##         carrier tailnum flight origin dest air_time distance hour min
##      1:      AA  N338AA      1    JFK  LAX      359     2475    9  14
##      2:      AA  N335AA      3    JFK  LAX      363     2475   11  57
##      3:      AA  N327AA     21    JFK  LAX      351     2475   19   2
##      4:      AA  N3EHAA     29    LGA  PBI      157     1035    7  22
##      5:      AA  N319AA    117    JFK  LAX      350     2475   13  47
##     ---                                                              
## 253312:      UA  N23708   1744    LGA  IAH      201     1416   14  59
## 253313:      UA  N33132   1758    EWR  IAH      189     1400    8  54
## 253314:      MQ  N827MQ   3591    LGA  RDU       83      431   11   2
## 253315:      MQ  N511MQ   3592    LGA  DTW       75      502   11   6
## 253316:      MQ  N813MQ   3599    LGA  SDF      110      659    8  24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(flights)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;data.table&amp;quot; &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;2.基础&lt;/h1&gt;
&lt;p&gt;flights的类型显示为data.table和data.frame。也可以通过&lt;code&gt;as.data.table()&lt;/code&gt;将对象转化为data.table类型。&lt;br /&gt;
读取形式 语法如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DT[i, j, by]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中i表示行过滤（实际上按照行选择数据集），j表示对列进行选择，by表示根据什么条件进行分组。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.1行过滤&lt;/h2&gt;
&lt;p&gt;首先来看一下，如何对行进行过滤。譬如要获得6月份从JFK机场起飞，途径纽约或者终点是纽约的航班信息。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.JFK &amp;lt;-  flights[origin==&amp;quot;JFK&amp;quot; &amp;amp; month == 6L]
head(flights.JFK)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     6   1      851        -9     1205        -5         0      AA
## 2: 2014     6   1     1220       -10     1522       -13         0      AA
## 3: 2014     6   1      718        18     1014        -1         0      AA
## 4: 2014     6   1     1024        -6     1314       -16         0      AA
## 5: 2014     6   1     1841        -4     2125       -45         0      AA
## 6: 2014     6   1     1454        -6     1757       -23         0      AA
##    tailnum flight origin dest air_time distance hour min
## 1:  N787AA      1    JFK  LAX      324     2475    8  51
## 2:  N795AA      3    JFK  LAX      329     2475   12  20
## 3:  N784AA      9    JFK  LAX      326     2475    7  18
## 4:  N791AA     19    JFK  LAX      320     2475   10  24
## 5:  N790AA     21    JFK  LAX      326     2475   18  41
## 6:  N785AA    117    JFK  LAX      329     2475   14  54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data.table的语法跟dplyr类似，不需要加上数据框名（&lt;code&gt;flights$origin&lt;/code&gt;）,大幅度简化。&lt;br /&gt;
另外一种写法&lt;code&gt;flights.JFK &amp;lt;-  flights[origin==&amp;quot;JFK&amp;quot; &amp;amp; month == 6L,,]&lt;/code&gt;也是可以的。这种写法，在data frame是不行的。&lt;br /&gt;
## 行排序 可以利用&lt;code&gt;order()&lt;/code&gt;函数来完成。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.sort &amp;lt;- flights[order(origin,-dest),]
head(flights.sort)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    year month day dep_time dep_delay arr_time arr_delay cancelled carrier
## 1: 2014     1   5      836         6     1151        49         0      EV
## 2: 2014     1   6      833         7     1111        13         0      EV
## 3: 2014     1   7      811        -6     1035       -13         0      EV
## 4: 2014     1   8      810        -7     1036       -12         0      EV
## 5: 2014     1   9      833        16     1055         7         0      EV
## 6: 2014     1  13      923        66     1154        66         0      EV
##    tailnum flight origin dest air_time distance hour min
## 1:  N12175   4419    EWR  XNA      195     1131    8  36
## 2:  N24128   4419    EWR  XNA      190     1131    8  33
## 3:  N12142   4419    EWR  XNA      179     1131    8  11
## 4:  N11193   4419    EWR  XNA      184     1131    8  10
## 5:  N14198   4419    EWR  XNA      181     1131    8  33
## 6:  N12157   4419    EWR  XNA      188     1131    9  23&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;order()&lt;/code&gt;实际上调用了data.table的快速基数排序函数&lt;code&gt;forder()&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2选择列&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.arr_delay &amp;lt;- flights[,arr_delay]
head(flights.arr_delay)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1]  13  13   9 -26   1   0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请注意，返回值是向量。&lt;br /&gt;
如果想返回值是data.table，需要在列名称前加一个list&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.arr_delay.dt &amp;lt;- flights[,list(arr_delay)]
head(flights.arr_delay.dt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    arr_delay
## 1:        13
## 2:        13
## 3:         9
## 4:       -26
## 5:         1
## 6:         0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;list()&lt;/code&gt;也可以用&lt;code&gt;.()&lt;/code&gt;代替，提高写作效率。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.arr_delay.dt.2 &amp;lt;- flights[,.(arr_delay)]
head(flights.arr_delay.dt.2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    arr_delay
## 1:        13
## 2:        13
## 3:         9
## 4:       -26
## 5:         1
## 6:         0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继续选取两列,列变量名称用&lt;code&gt;.()&lt;/code&gt;包括，返回data.table类型。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.arr_delay.dep_delay &amp;lt;- flights[,.(arr_delay,dep_delay)]
head(flights.arr_delay.dep_delay)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    arr_delay dep_delay
## 1:        13        14
## 2:        13        -3
## 3:         9         2
## 4:       -26        -8
## 5:         1         2
## 6:         0         4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一种形式：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.arr_delay.dep_delay &amp;lt;- flights[,c(&amp;quot;arr_delay&amp;quot;,&amp;quot;dep_delay&amp;quot;),with=FALSE]
head(flights.arr_delay.dep_delay)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    arr_delay dep_delay
## 1:        13        14
## 2:        13        -3
## 3:         9         2
## 4:       -26        -8
## 5:         1         2
## 6:         0         4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(flights.arr_delay.dep_delay)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;data.table&amp;quot; &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接对列变量重新命名&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.new &amp;lt;- flights[,.(delay_arr = arr_delay, delay_dep = dep_delay)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.3列运算&lt;/h2&gt;
&lt;p&gt;这是个新概念，理解起来有些困难。先看例子,计算有多少个航班没有延误。&lt;br /&gt;
具体的计算逻辑是这样的：到达和出发延迟时间均为负值，那么&lt;code&gt;(arr_delay+dep_delay)&amp;lt;0&lt;/code&gt;如果为真，表示该航班延误了，那么这个表达式的值是TRUE，同时也等于1，再进行sum()求和，实际上获得了延误航班的总数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.nodelay.num &amp;lt;- flights[,sum((arr_delay+dep_delay)&amp;lt;0)]
flights.nodelay.num&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 141814&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上式中，可以看出,&lt;code&gt;sum((arr_delay+dep_delay)&amp;lt;0)&lt;/code&gt;实际上是针对数据集的一个操作，只是在&lt;code&gt;[]&lt;/code&gt;内完成而已。&lt;/p&gt;
&lt;p&gt;进一步看下一个例子：计算6月份从JFK机场起飞的航班中，起飞和延误的平均时间:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.JFK.stats &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L,
                             .(m_arr=mean(arr_delay),m_dep=mean(dep_delay))]
flights.JFK.stats&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       m_arr    m_dep
## 1: 5.839349 9.807884&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;class(flights.JFK.stats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;data.table&amp;quot; &amp;quot;data.frame&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种操作跟dplyr中的summarise函数的功能是类似的。虽然网上说dplyr更加容易操作和理解，但是就我本人而言，data.table这种操作方式更加简洁，好用。&lt;br /&gt;
来自 &lt;a href=&#34;http://blog.csdn.net/smart_xiao_xiong/article/details/51658262&#34; class=&#34;uri&#34;&gt;http://blog.csdn.net/smart_xiao_xiong/article/details/51658262&lt;/a&gt; 的解释（性能更好的原因，同时提取符合条件的列和行，而不是分步，先行后列）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们首先在i参数里，找到所有符合 origin (机场)是“JFK”，并且 month (月份)是 6 这样条件的行。此时，我们还没有subset整个data.table。&lt;/li&gt;
&lt;li&gt;现在，我们看看参数j，它只使用了两列。我们需要分别计算这两列的平均值 mean()。这个时候，我们才subset那些符合i参数里条件的列，然后计算它们的平均值。 因为这三个参数（i，j和by）都被指定在同一个方括号中，data.table能同时接受这三个参数，并在计算之前，选取最优的计算方法，而不是分步骤计算。所以，我们可以避免对整个data.table计算，同时，在计算速度和内存使用量这两方面，取得最优的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们想看一下，从JFK机场起飞的航班一共有多少架次。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.JFK.num &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L,length(dest)]
flights.JFK.num&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8422&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，我只是需要知道符合条件的行数，&lt;code&gt;length()&lt;/code&gt;中的参数理论上可以是任何一列。data.table中定义了一个内建的变量&lt;code&gt;.N&lt;/code&gt;，表示当前的分组中对象的数目。因此上边的代码，可以写的更加简洁和可理解。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.JFK.num &amp;lt;- flights[origin == &amp;quot;JFK&amp;quot; &amp;amp; month == 6L, .N]
flights.JFK.num&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 8422&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;3.聚合&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.1 分组&lt;/h2&gt;
&lt;p&gt;获得每个机场起飞航班数&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.dep.num.per.airport &amp;lt;- flights[,.(.N),by=.(origin)]
flights.dep.num.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    origin     N
## 1:    JFK 81483
## 2:    LGA 84433
## 3:    EWR 87400&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当参数j和by，也就是第2个和第3个参数只有1列时，可以不用&lt;code&gt;.()&lt;/code&gt;。上述代码可以简化为：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.dep.num.per.airport &amp;lt;- flights[,.N,by=origin]
flights.dep.num.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    origin     N
## 1:    JFK 81483
## 2:    LGA 84433
## 3:    EWR 87400&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取一个制定航空公司在每个机场的起飞航班数，譬如美航（AA）。 在&lt;code&gt;i&lt;/code&gt;参数中设置条件过滤需要的行。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.AA.dep.num.per.airport &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;,.(.N),by=.(origin)]
flights.AA.dep.num.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    origin     N
## 1:    JFK 11923
## 2:    LGA 11730
## 3:    EWR  2649&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取AA航空公司在所有机场起飞和降落的航班数&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.AA.dep.dest.num.per.airport &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;,.(.N),by=.(origin,dest)]
flights.AA.dep.dest.num.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     origin dest    N
##  1:    JFK  LAX 3387
##  2:    LGA  PBI  245
##  3:    EWR  LAX   62
##  4:    JFK  MIA 1876
##  5:    JFK  SEA  298
##  6:    EWR  MIA  848
##  7:    JFK  SFO 1312
##  8:    JFK  BOS 1173
##  9:    JFK  ORD  432
## 10:    JFK  IAH    7
## 11:    JFK  AUS  297
## 12:    EWR  DFW 1618
## 13:    LGA  ORD 4366
## 14:    JFK  STT  229
## 15:    JFK  SJU  690
## 16:    LGA  MIA 3334
## 17:    LGA  DFW 3785
## 18:    JFK  LAS  595
## 19:    JFK  MCO  597
## 20:    JFK  EGE   85
## 21:    JFK  DFW  474
## 22:    JFK  SAN  299
## 23:    JFK  DCA  172
## 24:    EWR  PHX  121
##     origin dest    N&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;想进一步分析在所有机场，每个月起降的平均延误时间。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.AA.dep.dest.stats.per.airport &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;,.(.N,MeanArrDelay=mean(arr_delay),MeanDepDelay=mean(dep_delay)),by=.(origin,dest,month)]
flights.AA.dep.dest.stats.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      origin dest month   N MeanArrDelay MeanDepDelay
##   1:    JFK  LAX     1 249     6.590361   14.2289157
##   2:    LGA  PBI     1  58    -7.758621    0.3103448
##   3:    EWR  LAX     1  30     1.366667    7.5000000
##   4:    JFK  MIA     1 179    15.720670   18.7430168
##   5:    JFK  SEA     1  28    14.357143   30.7500000
##  ---                                                
## 196:    LGA  MIA    10 278    -6.251799   -1.4208633
## 197:    JFK  MIA    10 217    -1.880184    6.6774194
## 198:    EWR  PHX    10  31    -3.032258   -4.2903226
## 199:    JFK  MCO    10  62   -10.048387   -1.6129032
## 200:    JFK  DCA    10  31    16.483871   15.5161290&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分组结果如何按照升降序排列。需要keyby参数代替by。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.AA.dep.dest.stats.per.airport &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;,.(.N,MeanArrDelay=mean(arr_delay),MeanDepDelay=mean(dep_delay)),keyby=.(origin,dest,month)]
flights.AA.dep.dest.stats.per.airport&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      origin dest month   N MeanArrDelay MeanDepDelay
##   1:    EWR  DFW     1 159     6.427673   10.0125786
##   2:    EWR  DFW     2 136    10.536765   11.3455882
##   3:    EWR  DFW     3 163    12.865031    8.0797546
##   4:    EWR  DFW     4 164    17.792683   12.9207317
##   5:    EWR  DFW     5 164    18.487805   18.6829268
##  ---                                                
## 196:    LGA  PBI     1  58    -7.758621    0.3103448
## 197:    LGA  PBI     2  52    -7.865385    2.4038462
## 198:    LGA  PBI     3  61    -5.754098    3.0327869
## 199:    LGA  PBI     4  60   -13.966667   -4.7333333
## 200:    LGA  PBI     5  14   -10.357143   -6.8571429&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;-chaining&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.2 管道符 chaining&lt;/h2&gt;
&lt;p&gt;类似于 %&amp;gt;% ，实现连续操作，避免中间变量的生成。这个是非常强大的操作。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ans &amp;lt;- flights[carrier == &amp;quot;AA&amp;quot;, .N, by=.(origin, dest)][order(origin, -dest)]
head(ans,10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     origin dest    N
##  1:    EWR  PHX  121
##  2:    EWR  MIA  848
##  3:    EWR  LAX   62
##  4:    EWR  DFW 1618
##  5:    JFK  STT  229
##  6:    JFK  SJU  690
##  7:    JFK  SFO 1312
##  8:    JFK  SEA  298
##  9:    JFK  SAN  299
## 10:    JFK  ORD  432&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以多个表达式链接&lt;code&gt;DT[...][...][...][...]&lt;/code&gt;，另外一种形式，也是可以接受的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DT[...
][...
][...
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;by&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.3 by参数表达式&lt;/h2&gt;
&lt;p&gt;参数by也可以接受表达式 譬如，想看一下有多少航班起飞延误但却提前／准时到达的，有多少航班起飞和到达都延误了。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ans &amp;lt;- flights[, .N, .(dep_delay&amp;gt;0, arr_delay&amp;gt;0)]
ans&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    dep_delay arr_delay      N
## 1:      TRUE      TRUE  72836
## 2:     FALSE      TRUE  34583
## 3:     FALSE     FALSE 119304
## 4:      TRUE     FALSE  26593&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也是一个比较牛逼的用法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.4 对多列同时进行统一运算&lt;/h2&gt;
&lt;p&gt;譬如有1000列，要对每一列进行均值计算。传统可以通过lapply函数来进行。如果存在分组的情况，该如何操作？data.table提供了&lt;code&gt;.SD&lt;/code&gt;，表示Subset of Data，本身是一个data.table，包括&lt;strong&gt;通过by分组后的每一组&lt;/strong&gt;。 实例来看一下，对于起飞机场的一个分组&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.SD &amp;lt;- flights[,.(origin,dep_time,arr_time,air_time,distance,hour,min)][,.SD,by=origin]
flights.SD&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         origin dep_time arr_time air_time distance hour min
##      1:    JFK      914     1238      359     2475    9  14
##      2:    JFK     1157     1523      363     2475   11  57
##      3:    JFK     1902     2224      351     2475   19   2
##      4:    JFK     1347     1706      350     2475   13  47
##      5:    JFK     2133       37      338     2475   21  33
##     ---                                                    
## 253312:    EWR     1242     1549      344     2565   12  42
## 253313:    EWR     2121     2224      100      719   21  21
## 253314:    EWR     1049     1335      326     2454   10  49
## 253315:    EWR     1653     1910      291     2227   16  53
## 253316:    EWR      854     1147      189     1400    8  54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个分组，按照origin整齐排列。 对于除了分组列外的其他列，统一求平均值，并且保留两位小数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.SD.mean &amp;lt;- flights[,.(origin,dep_time,arr_time,air_time,distance,hour,min)][,lapply(.SD,mean),by=origin][,round(.SD,2),by=origin]
flights.SD.mean&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    origin dep_time arr_time air_time distance  hour   min
## 1:    JFK  1359.69  1488.90   195.28  1413.86 13.27 32.34
## 2:    LGA  1315.07  1500.38   116.46   777.47 12.82 33.20
## 3:    EWR  1340.62  1493.54   159.68  1117.36 13.10 30.22&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如何进一步获取制定列的均值。答案是通过.SDcols参数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;flights.SD.mean &amp;lt;- flights[,.(origin,dep_time,arr_time,air_time,distance,hour,min)][,lapply(.SD,mean),.SDcols=c(&amp;quot;dep_time&amp;quot;,&amp;quot;arr_time&amp;quot;),by=origin][,round(.SD,2),by=origin]
flights.SD.mean&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    origin dep_time arr_time
## 1:    JFK  1359.69  1488.90
## 2:    LGA  1315.07  1500.38
## 3:    EWR  1340.62  1493.54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现类似melt的功能，把多列合并为一列。 首先生成一个数据集&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT = data.table(ID = c(&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;c&amp;quot;), a = 1:6, b = 7:12, c=13:18)
DT&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    ID a  b  c
## 1:  b 1  7 13
## 2:  b 2  8 14
## 3:  b 3  9 15
## 4:  a 4 10 16
## 5:  a 5 11 17
## 6:  c 6 12 18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，把a，b，c三列合并为1列。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT.new &amp;lt;- DT[,.(abc=c(a,b,c)),by=ID]
DT.new&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     ID abc
##  1:  b   1
##  2:  b   2
##  3:  b   3
##  4:  b   7
##  5:  b   8
##  6:  b   9
##  7:  b  13
##  8:  b  14
##  9:  b  15
## 10:  a   4
## 11:  a   5
## 12:  a  10
## 13:  a  11
## 14:  a  16
## 15:  a  17
## 16:  c   6
## 17:  c  12
## 18:  c  18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;j参数非常强大，也可以a,b,c三列的结果，作为一个列表返回。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT.new.list &amp;lt;- DT[,.(abc=list(c(a,b,c))),by=ID]
DT.new.list&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    ID               abc
## 1:  b      1,2,3,7,8,9,
## 2:  a  4, 5,10,11,16,17
## 3:  c           6,12,18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并a，b，c三列，作为字符串。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;DT.new.str &amp;lt;- DT[,.(abc=paste(a,b,c,sep = &amp;quot;&amp;quot;)),by=ID]
DT.new.str&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    ID   abc
## 1:  b  1713
## 2:  b  2814
## 3:  b  3915
## 4:  a 41016
## 5:  a 51117
## 6:  c 61218&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Rcpp读书笔记2-第二章工具与设置</title>
      <link>/post/rcpp-note-2/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/rcpp-note-2/</guid>
      <description>

&lt;h2 id=&#34;2-1-总体设置&#34;&gt;2.1 总体设置&lt;/h2&gt;

&lt;p&gt;Rcpp提供一个C++应用编程接口（API），来扩展R系统。运行Rcpp和R的一些需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发环境需要一个C++编译器。&lt;/li&gt;
&lt;li&gt;通过动态链接和嵌入方式，供R调用。&lt;/li&gt;
&lt;li&gt;在windows下，一般会通过安装Rtools来提供开发环境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编译R包所需要的标准环境，通常也是编译Rcpp所需要的。&lt;br /&gt;
几个附加的R包非常有用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;inline 对于一些短的C++代码，可以直接通过inline内部编译和调用。&lt;/li&gt;
&lt;li&gt;rbenchmark 用来对比测试不同代码的性能。microbenchmark包也是一个非常好的选择。&lt;/li&gt;
&lt;li&gt;RUnit 用作单元测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-编译器&#34;&gt;2.2 编译器&lt;/h2&gt;

&lt;p&gt;windows下，通常使用Rtools自带的g++编译器。&lt;/p&gt;

&lt;h2 id=&#34;2-3-r-api&#34;&gt;2.3 R API&lt;/h2&gt;

&lt;p&gt;R自身提供了API。API在“Writting R Extensions”手册中进行了详细描述，定义了R安装所需要的头文件。R核心开发团队，建议只使用公开的API。其他API可能会修改或者改变，而不会通知开发者。&lt;/p&gt;

&lt;p&gt;有几本书描述了R API函数。可以参考的包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Venables WN, Ripley BD (2000) S Programming. Statistics and Computing, pringer-Verlag, New York&lt;/li&gt;
&lt;li&gt;Gentleman R (2009) R Programming for Bioinformatics. Computer Science and
Data Analysis, Chapman &amp;amp; Hall/CRC, Boca Raton, FL&lt;/li&gt;
&lt;li&gt;Chambers JM (2008) Software for Data Analysis: Programming with R. Statistics
and Computing, Springer, Heidelberg, ISBN 978-0-387-75935-7&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个基本的扩展函数：&lt;code&gt;.C()&lt;/code&gt;和&lt;code&gt;.Call()&lt;/code&gt;。其中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.C()&lt;/code&gt;c存在于R语言的早期版本，并被严格限制使用。仅仅用于支持基本的C类型的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Call()&lt;/code&gt;被广泛应用。该函数主要操作SEXP 对象，代表S expression object的指针。在R内部，本质上任何对象都是SEXP对象。通过在C++和R之间交换对象，实现对R对象的直接操作。Rcpp只使用&lt;code&gt;.Call()&lt;/code&gt;进行内部调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rcpp本质上是建立在R API基础上的一个补充的接口，可以更好的扩展R。利用C++程序，生成更多可供R调用的工具，来提高R编程的效率。&lt;/p&gt;

&lt;h2 id=&#34;2-4-rcpp的首次编译&#34;&gt;2.4 Rcpp的首次编译&lt;/h2&gt;

&lt;p&gt;将下列C++代码存为fibonacii.cpp文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;Rcpp.h&amp;gt;
int fibonacci(const int x) {
  if (x == 0) return(0);
  if (x == 1) return(1);
  return (fibonacci(x - 1)) + fibonacci(x - 2);
}

extern &amp;quot;C&amp;quot; SEXP fibWrapper(SEXP xs) {
  int x = Rcpp::as&amp;lt;int&amp;gt;(xs);
  int fib = fibonacci(x);
  return (Rcpp::wrap(fib));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何编译上述代码？需要进行以下几项准备工作（本文主要针对windows 10系统下）：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先R CMD命令要可以运行。安装最新的&lt;a href=&#34;https://cran.r-project.org/bin/windows/Rtools/&#34; target=&#34;_blank&#34;&gt;Rtools&lt;/a&gt;。安装完成后，设置环境变量，在path中添加R主程序所在的路径，本文中用的是R3.4可执行文件所在的路径，本文所用路径为：&lt;code&gt;C:\Program Files\R\R-3.4.0patched\bin&lt;/code&gt;。添加完成后，Win+R，输入cmd，然后在命令行中输入path，查看是否添加成功。&lt;/li&gt;
&lt;li&gt;查找Rcpp包所在的路径，本文Rcpp包所在路径为&lt;code&gt;C:/Users/luan_/Documents/R/win-library/3.4/Rcpp/&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;注意windows输出的路径是&amp;rdquo;\&amp;ldquo;需要替换为&amp;rdquo;/&amp;ldquo;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完成上述两项工作后，win+R，输入cmd，通过cd命令切换到fibonacci.cpp文件所在的路径，在窗口中输入下边的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PKG_CXXFLAGS=&amp;quot;-I/C:/Users/luan_/Documents/R/win-library/3.4/Rcpp/include&amp;quot; \
PKG_LIBS=&amp;quot;-L/C:/Users/luan_/Documents/R/win-library/3.4/Rcpp/libs/x64 -lRcpp&amp;quot; \
R CMD SHLIB fibonacci.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;命令第一行表示头文件所在的路径；&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;命令第二行表示库文件所在的路径和名称；&lt;/li&gt;
&lt;li&gt;命令第三行表示编译和链接代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R CMD SHLIB命令执行后，会输出如下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c:/Rtools/mingw_64/bin/g++  -I&amp;quot;C:/PROGRA~1/R/R-34~1.0PA/include&amp;quot; -DNDEBUG 
                            -I &amp;quot;d:/Compiler/gcc-4.9.3/local330/include&amp;quot;  
                            -IC:/Users/luan_/Documents/R/win-library/3.4/Rcpp/include
                            -O2 -Wall  -mtune=core2 -c fibonacci.cpp -o fibonacci.o
c:/Rtools/mingw_64/bin/g++ -shared -s -static-libgcc -o fibonacci.dll tmp.def fibonacci.o 
                            -LC:/Users/luan_/Documents/R/win-library/3.4/Rcpp/libs/x64
                            -lRcpp -Ld:/Compiler/gcc-4.9.3/local330/lib/x64 
                            -Ld:/Compiler/gcc-4.9.3/local330/lib 
                            -LC:/PROGRA~1/R/R-34~1.0PA/bin/x64 -lR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令主要触发两个调用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一条命令将源文件fibonacci.cpp转换为目标文件fibonacci.o;&lt;/li&gt;
&lt;li&gt;第二条命令将目标文件fibonacci.io链接为一个共享库文件fibonacci.dll。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来的工作是调用生成的共享链接库fibonacci.dll文件。
在R中加载Rcpp库，通过&lt;code&gt;setwd()&lt;/code&gt;切换到fibonacci.dll所在路径,通过&lt;code&gt;dyn.load()&lt;/code&gt;和&lt;code&gt;.Call()&lt;/code&gt;进行加载和调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(Rcpp)
setwd(&amp;quot;C:/Users/luan_/luansheng/luansheng.github.io/code&amp;quot;)
dyn.load(&amp;quot;fibonacci.dll&amp;quot;)
.Call(&amp;quot;fibWrapper&amp;quot;,10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## [1] 55
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rcpp提供了2个script，来对最原始的代码进行辅助编译。
这里需要注意，由于Rcpp是通过Rstudio进行安装的，因此Rcpp并不在R的标准库路径下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;.Library
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;C:/PROGRA~1/R/R-34~1.0PA/library&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;.libPaths()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;C:/Users/luan_/Documents/R/win-library/3.4&amp;quot;
## [2] &amp;quot;C:/Program Files/R/R-3.4.0patched/library&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接运行下边的代码，显示找不到Rcpp，但是又找不到方法，把缺省的库设置为&lt;code&gt;C:/Users/luan_/Documents/R/win-library/3.4&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PKG_CXXFLAGS=`Rscript -e &#39;Rcpp:::CxxFlags()&#39;` \
PKG_LIBS=`Rscript -e &#39;Rcpp:::LdFlags()&#39;` \
R CMD SHLIB fibonacci.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-5-inline-包&#34;&gt;2.5 inline 包&lt;/h2&gt;

&lt;p&gt;现在再理解起来，比第一章要容易的多了。inline包适合快速开发，因为C++代码可以直接在R代码中书写，直接与R代码一起运行，C++代码的编译、链接和载入在后台进行，特别方便。&lt;/p&gt;

&lt;p&gt;inline提供函数&lt;code&gt;cfunction()&lt;/code&gt;和&lt;code&gt;cxxfunction()&lt;/code&gt;，在R会话中直接编译、链接和加载C++函数。
在&lt;code&gt;cxxfunction()&lt;/code&gt;函数中,可以设置plugin参数，用来指定头文件和库位置，在本文中，一般会指定为Rcpp。因此，为了简化使用，inline提供一个cxx&lt;code&gt;function()&lt;/code&gt;的替代函数&lt;code&gt;rcpp()&lt;/code&gt;,默认plugin为rcpp。&lt;/p&gt;

&lt;p&gt;来看一个示例代码，卷积的计算公式。
卷积好像是一种预测，对不停的信号输入，可以预测其输出。知乎上有个以复利进行解释的的例子，比较容易的理解。&lt;a href=&#34;https://www.zhihu.com/question/22298352&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/22298352&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;##定义C++代码
src &amp;lt;- &#39;
Rcpp::NumericVector xa(a);
Rcpp::NumericVector xb(b);
int n_xa =xa.size(), n_xb = xb.size();

Rcpp::NumericVector xab(n_xa + n_xb-1);
for (int i=0; i &amp;lt; n_xa; i++)
  for (int j=0; j &amp;lt; n_xb; j++)
    xab[i+j] += xa[i] * xb[j];
return xab;
&#39;

###定义在R中调用的接口函数
fun &amp;lt;- cxxfunction(signature(a=&amp;quot;numeric&amp;quot;,b=&amp;quot;numeric&amp;quot;),
src,plugin=&amp;quot;Rcpp&amp;quot;)

#利用rcpp函数定义接口函数
funrcpp &amp;lt;-  rcpp(signature(a=&amp;quot;numerci&amp;quot;,b=&amp;quot;numeric&amp;quot;),src)

##记得加载Rcpp和inline两个包，不然会找不到Rcpp调用的类型和函数
require(Rcpp)
require(inline)
fun(1:4,2:5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1]  2  7 16 30 34 31 20
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;funrcpp(1:4,2:5)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## [1]  2  7 16 30 34 31 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数中添加&lt;code&gt;verbose=TRUE&lt;/code&gt;参数可以显示&lt;code&gt;cxxfunction()&lt;/code&gt;生成的临时文件和R CMD SHLIB触发的调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;funverbose &amp;lt;- cxxfunction(signature(a=&amp;quot;numeric&amp;quot;,b=&amp;quot;numeric&amp;quot;),
src,plugin=&amp;quot;Rcpp&amp;quot;,verbose = TRUE)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##  &amp;gt;&amp;gt; setting environment variables: 
## PKG_LIBS = 
## 
##  &amp;gt;&amp;gt; LinkingTo : Rcpp
## CLINK_CPPFLAGS =  -I&amp;quot;C:/Users/luan_/Documents/R/win-library/3.4/Rcpp/include&amp;quot; 
## 
##  &amp;gt;&amp;gt; Program source :
## 
##    1 : 
##    2 : // includes from the plugin
##    3 : 
##    4 : #include &amp;lt;Rcpp.h&amp;gt;
##    5 : 
##    6 : 
##    7 : #ifndef BEGIN_RCPP
##    8 : #define BEGIN_RCPP
##    9 : #endif
##   10 : 
##   11 : #ifndef END_RCPP
##   12 : #define END_RCPP
##   13 : #endif
##   14 : 
##   15 : using namespace Rcpp;
##   16 : 
##   17 : 
##   18 : // user includes
##   19 : 
##   20 : 
##   21 : // declarations
##   22 : extern &amp;quot;C&amp;quot; {
##   23 : SEXP file9864474b192a( SEXP a, SEXP b) ;
##   24 : }
##   25 : 
##   26 : // definition
##   27 : 
##   28 : SEXP file9864474b192a( SEXP a, SEXP b ){
##   29 : BEGIN_RCPP
##   30 : 
##   31 : Rcpp::NumericVector xa(a);
##   32 : Rcpp::NumericVector xb(b);
##   33 : int n_xa =xa.size(), n_xb = xb.size();
##   34 : 
##   35 : Rcpp::NumericVector xab(n_xa + n_xb-1);
##   36 : for (int i=0; i &amp;lt; n_xa; i++)
##   37 :   for (int j=0; j &amp;lt; n_xb; j++)
##   38 :     xab[i+j] += xa[i] * xb[j];
##   39 : return xab;
##   40 : 
##   41 : END_RCPP
##   42 : }
##   43 : 
##   44 : 
## Compilation argument:
##  C:/PROGRA~1/R/R-34~1.0PA/bin/x64/R CMD SHLIB file9864474b192a.cpp 2&amp;gt; file9864474b192a.cpp.err.txt
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>BLUP公式及分解</title>
      <link>/post/lmm-for-ebv-prediction-blup/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/lmm-for-ebv-prediction-blup/</guid>
      <description>&lt;div id=&#34;blup&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1. BLUP公式&lt;/h1&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{bmatrix} X^{&amp;#39;}\hat{R}^{-1}X &amp;amp; X^{&amp;#39;}\hat{R}^{-1}Z \\ Z^{&amp;#39;}\hat{R}^{-1}X &amp;amp; Z^{&amp;#39;}\hat{R}^{-1}Z+\hat{G}^{-1} \end{bmatrix} \begin{bmatrix} \hat{\beta} \\ \hat{u} \end{bmatrix} = \begin{bmatrix} X^{&amp;#39;}\hat{R}^{-1}y \\ Z^{&amp;#39;}\hat{R}^{-1}y \end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
